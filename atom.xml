<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zfylin-非鱼</title>
  <subtitle>子非鱼焉知鱼之乐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-10T06:36:03.424Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zfylin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python基础&amp;函数</title>
    <link href="http://yoursite.com/2017/04/10/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-python%E5%9F%BA%E7%A1%80&amp;%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/04/10/python3学习笔记-python基础&amp;函数/</id>
    <published>2017-04-10T06:35:42.000Z</published>
    <updated>2017-04-10T06:36:03.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-基础"><a href="#python-基础" class="headerlink" title="python 基础"></a>python 基础</h1><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ol>
<li>基本数据类型<ul>
<li>整数型：任意大小整数，无short,int,long区分 0x表示16进制</li>
<li>浮点型：即小数（科学计数法小数点可浮动）。 <strong><em>PS：整数运算永远准确，浮点数运算存在四舍五入</em></strong></li>
<li>字符串：用’’或””括起来的内容 。 <strong><em>PS：转义字符：‘\’。不转义：r’…’。多行内容：’’’…’’’</em></strong></li>
<li>布尔值：True，False。<em>PS：and or not运算</em></li>
<li>空值：None</li>
</ul>
</li>
<li>变量：下划线、字母、数字组合不能以数字开头。 <strong><em>PS：动态语言，变量无类型</em></strong></li>
<li>常量：名称通常大写。<strong>实际无法约束常量不变</strong></li>
</ol>
<h2 id="字符串与编码"><a href="#字符串与编码" class="headerlink" title="字符串与编码"></a>字符串与编码</h2><ol>
<li>字符编码<ul>
<li>一个比特位只能表示0或者1</li>
<li>8个比特位表示一个字节</li>
<li>n个字节可以表示一个字符（n视编码方式而定）</li>
<li>ASCII编码：一个字节，只能表示英文及常用字符</li>
<li>Unicode编码：常用两个字节表示，通用</li>
<li>UTF-8编码：变字节长度，英文一个字节，兼容ASCII，中文３个</li>
<li><strong>存储和网络传输常用UTF-8，内存中常用Unicode</strong></li>
</ul>
</li>
<li>字符串<ul>
<li>ord()函数：取字符整数表示</li>
<li>chr()函数：取整数字符表示</li>
<li>b’…’表示比特类型数据</li>
<li>.encode(‘utf-8,ascii,unicode’)函数，将字符按指定编码方式编码为比特型</li>
<li>.decode(‘utf-8,ascii,unicode’)函数，将比特按指定编码方式编码为字符</li>
</ul>
</li>
<li>格式化字符串<ul>
<li>%d 整数型</li>
<li>%s 字符串型</li>
<li>%f 浮点数型</li>
<li>%x 十六进制整数型 PS：整数和浮点数型可指定是否补0或小数点位数（%02d,%.2f）</li>
</ul>
</li>
</ol>
<h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><ol>
<li>list(列表)<ul>
<li>list是一种有序的集合，可以随时添加和删除其中的元素</li>
<li>定义：mylist = [e1,e2…]</li>
</ul>
</li>
<li>tuple(元祖)    <ul>
<li>tuple和list非常类似，但是tuple一旦初始化就不能修改</li>
<li>定义：mytuple = (e1,e2…)</li>
</ul>
</li>
<li>list和tuple是Python内置的有序集合，一个可变，一个不可变。</li>
</ol>
<h2 id="dict-与-set"><a href="#dict-与-set" class="headerlink" title="dict 与 set"></a>dict 与 set</h2><ol>
<li>dict(字典，同java map)<ul>
<li>使用哈希函数实现，查找快，占用内存多</li>
<li>定义：mydict = {key1:value,key2:value2,…,keyn:valuen} </li>
</ul>
</li>
<li>set(集合)<ul>
<li>key集合，key不重复 </li>
<li>定义：myset = set([一个列表])</li>
</ul>
</li>
<li>不可变对象<ul>
<li><font color="red"><strong>通过对象自身的任何方法都不能改变对象自身的内容</strong></font></li>
<li>ps: 通过对象自身的任何方法都不能改变对象自身的内容</li>
</ul>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol>
<li><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def function_name(x):</div><div class="line">        return x</div></pre></td></tr></table></figure>
</li>
<li><p>空函数: pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def nop():</div><div class="line">    pass</div></pre></td></tr></table></figure>
</li>
<li><p>返回多个值: 函数可以同时返回多个值，但其实就是一个tuple。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import math</div><div class="line"></div><div class="line">def move(x, y, step, angle=0):</div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    return nx, ny</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ol>
<li>位置参数</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
<li>命名关键字参数</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-基础&quot;&gt;&lt;a href=&quot;#python-基础&quot; class=&quot;headerlink&quot; title=&quot;python 基础&quot;&gt;&lt;/a&gt;python 基础&lt;/h1&gt;&lt;h2 id=&quot;数据类型和变量&quot;&gt;&lt;a href=&quot;#数据类型和变量&quot; class=&quot;he
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="http://yoursite.com/2017/03/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2017/03/31/面向对象设计原则/</id>
    <published>2017-03-31T09:29:18.000Z</published>
    <updated>2017-03-31T09:37:57.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p> 对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p>
</blockquote>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</strong></p>
<p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>
<p><font color="red"><strong>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则</strong></font>，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</strong></p>
<p><strong>在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p>
<p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。<br>      为了满足开闭原则，需要对系统进行抽象化设计，<strong>抽象化是开闭原则的关键</strong>。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><strong>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong>。</p>
<p> 里氏代换原则告诉我们，<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象</strong>。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p>
<p>例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</p>
<p><strong>里氏代换原则是实现开闭原则的重要方式之一</strong>，由于使用基类对象的地方都可以使用子类对象，因此在<strong>程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p>
<p>在使用里氏代换原则时需要注意如下几个问题：</p>
<ol>
<li><strong>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法</strong>。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li>
<li><strong>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法</strong>，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</li>
<li>Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</li>
</ol>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><strong>依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</strong></p>
<p><font color="red">依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</font>为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p>
<p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p>
<p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过<font color="red"><strong>依赖注入(DependencyInjection, DI)</strong></font>的方式注入到其他对象中，<font color="red"><strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象</strong></font>。常用的注入方式有三种，分别是：<strong>构造注入，设值注入（Setter注入）和接口注入</strong>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p>
<p>在大多数情况下，这三个设计原则会同时出现，<font color="red"><strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段</strong></font>，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><strong>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</strong></p>
<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<font color="red"><strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干</strong></font>。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p>
<ol>
<li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“<strong>角色隔离原则</strong>”。</li>
<li>如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来</strong>，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“<strong>定制服务</strong>”，即为不同的客户端提供宽窄不同的接口。</li>
</ol>
<p>在使用接口隔离原则时，我们需要注意控制接口的粒度，<font color="red"><strong>接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便</strong></font>。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><strong>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。</strong></p>
<p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：<font color="red"><strong>复用时要尽量使用组合/聚合关系（关联关系），少用继承</strong></font>。</p>
<p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>
<p>  通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p><strong>迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p>
<p>   如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>
<p>迪米特法则还有几种定义形式，包括：<strong>不要和“陌生人”说话、只与你的直接朋友通信</strong>等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p>
<ol>
<li><strong>当前对象本身(this)</strong>；</li>
<li><strong>以参数形式传入到当前对象方法中的对象</strong>；</li>
<li><strong>当前对象的成员对象</strong>；</li>
<li><strong>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</strong>；</li>
<li><strong>当前对象所创建的对象</strong>。</li>
</ol>
<p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。<br>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个<font color="red">合理的第三者</font>来降低现有对象之间的耦合度。</strong></p>
<p>在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.csdn.net/lovelion/article/details/7537584" target="_blank" rel="external">开闭原则</a><br><a href="http://blog.csdn.net/lovelion/article/details/7540445" target="_blank" rel="external">里氏代换原则</a><br><a href="http://blog.csdn.net/lovelion/article/details/7562783" target="_blank" rel="external">依赖倒转原则</a><br><a href="http://blog.csdn.net/lovelion/article/details/7562842" target="_blank" rel="external">接口隔离原则</a><br><a href="http://blog.csdn.net/lovelion/article/details/7563445" target="_blank" rel="external">迪米特法则</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式， 面向对象" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>localhost与127.0.0.1、0.0.0.0的区别</title>
    <link href="http://yoursite.com/2017/03/24/localhost%E4%B8%8E127.0.0.1%E3%80%810.0.0.0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/03/24/localhost与127.0.0.1、0.0.0.0的区别/</id>
    <published>2017-03-24T08:19:08.000Z</published>
    <updated>2017-03-31T09:38:19.369Z</updated>
    
    <content type="html"><![CDATA[<p>localhost也叫local ，正确的解释是:<strong>本地服务器</strong><br>127.0.0.1在windows等系统的正确解释是:<strong>本机地址(本机服务器)</strong></p>
<p><strong>localhost(local)是不经网卡传输</strong>！这点很重要，它不受网络防火墙和网卡相关的的限制。<br><strong>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制</strong>。</p>
<p><strong>一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源</strong>。<br><strong>127.0.0.1不属于任何一个有类别地址类，通常被称为本地回环地址(Loop back address)，它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口</strong>。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。<strong>一般都会用来检查本地网络协议、基本数据接口等是否正常的。</strong></p>
<p><strong>0.0.0.0也是个特殊而且“不存在”的地址，通常代表所有的可用ip地址，默认路由就使用0.0.0.0加上一个特殊的子网掩码0.0.0.0来代表所有未知路由地址。</strong></p>
<p>也可以简单的这样理解：<br>127.0.0.1是本机的回环地址，ping 127.0.0.1就是自己ping自己，而且这个地址是经过网卡的，如果能ping 通，就表示网络协议是没问题的</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;localhost也叫local ，正确的解释是:&lt;strong&gt;本地服务器&lt;/strong&gt;&lt;br&gt;127.0.0.1在windows等系统的正确解释是:&lt;strong&gt;本机地址(本机服务器)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;localhost(local
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="localhost" scheme="http://yoursite.com/tags/localhost/"/>
    
  </entry>
  
  <entry>
    <title>什么是设计模式</title>
    <link href="http://yoursite.com/2017/03/24/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/24/什么是设计模式/</id>
    <published>2017-03-24T03:02:48.000Z</published>
    <updated>2017-03-31T09:39:08.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
</blockquote>
<p>设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。<strong>模式名称(Pattern Name)</strong>通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名，微笑）；<strong>问题(Problem)</strong>描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；<strong>解决方案(Solution)</strong>描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；<strong>效果(Consequences)</strong>描述了模式的优缺点以及在使用模式时应权衡的问题。<br>根据它们的用途，设计模式可分为<strong>创建型(Creational)</strong>，<strong>结构型(Structural)</strong>和<strong>行为型(Behavioral)</strong>三种，其中<font color="red"><strong>创建型</strong>模式主要用于描述如何创建对象，<strong>结构型</strong>模式主要用于描述如何实现类或对象的组合，<strong>行为型</strong>模式主要用于描述类或对象怎样交互以及怎样分配职责</font>，在GoF 23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。此外，<font color="red">根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为<strong>类模式</strong>和<strong>对象模式</strong></font>。我们经常将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。</p>
<p><img src="./snipaste20170324_104705.png" alt="Alt text"></p>
<p>在学习每一个设计模式时至少应该掌握如下几点：<strong>这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么</strong>。</p>
<p><strong>模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平。模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。</strong> </p>
<p><a href="http://blog.csdn.net/lovelion/article/details/7420866" target="_blank" rel="external">参考链接-设计模式有什么用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计模式一般包含模式名称
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop MR &amp;&amp; YARN</title>
    <link href="http://yoursite.com/2017/03/15/Hadoop%20MR%20&amp;&amp;%20YARN/"/>
    <id>http://yoursite.com/2017/03/15/Hadoop MR &amp;&amp; YARN/</id>
    <published>2017-03-15T09:37:40.000Z</published>
    <updated>2017-03-15T09:44:01.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Apache Hadoop 是一个开源软件框架，可安装在一个商用机器集群中，使机器可彼此通信并协同工作，以高度分布式的方式共同存储和处理大量数据。最初，Hadoop 包含以下两个主要组件：<strong>Hadoop Distributed File System (HDFS)</strong> 和<strong>一个分布式计算引擎</strong>，该引擎支持以 MapReduce 作业的形式实现和运行程序。<br><strong>MapReduce</strong> 是 Google 推广的一个简单的编程模型，它对以高度并行和可扩展的方式处理大数据集很有用。MapReduce 的灵感来源于函数式编程，用户可将他们的计算表达为 map 和 reduce 函数，将数据作为键值对来处理。Hadoop 提供了一个高级 API 来在各种语言中实现自定义的 map 和 reduce 函数。<br>Hadoop 还提供了软件基础架构，以一系列 map 和 reduce 任务的形式运行 MapReduce 作业。Map 任务 在输入数据的子集上调用 map 函数。在完成这些调用后，reduce 任务 开始在 map 函数所生成的中间数据上调用 reduce 任务，生成最终的输出。 map 和 reduce 任务彼此单独运行，这支持并行和容错的计算。<br>最重要的是，Hadoop 基础架构负责处理分布式处理的所有复杂方面：并行化、调度、资源管理、机器间通信、软件和硬件故障处理，等等。得益于这种干净的抽象，实现处理数百（或者甚至数千）个机器上的数 TB 数据的分布式应用程序从未像现在这么容易过，甚至对于之前没有使用分布式系统的经验的开发人员也是如此。</p>
</blockquote>
<h2 id="MR架构"><a href="#MR架构" class="headerlink" title="MR架构"></a>MR架构</h2><p>在运行一个mapreduce计算任务时候，任务过程被分为两个阶段：map阶段和reduce阶段，每个阶段都是用键值对（key/value）作为输入（input）和输出（output）。而程序员要做的就是定义好这两个阶段的函数：map函数和reduce函数。</p>
<center><img src="http://p1.bpimg.com/567571/782bf941ee647106.png" alt=""></center><br><center>map reduce 过程图</center>

<h2 id="JobClient-JobTracker-TaskTracker"><a href="#JobClient-JobTracker-TaskTracker" class="headerlink" title="JobClient JobTracker TaskTracker"></a>JobClient JobTracker TaskTracker</h2><center><img src="http://p1.bpimg.com/567571/8c0a589b9cf56e5c.png" alt=""></center><br><center>MR 架构</center>

<ol>
<li>JobClient 向 JobTracker 请求一个新的 jobID</li>
<li>检查作业输出说明</li>
<li>计算作业输出划分split</li>
<li>将运行作业所需要的资源（作业的jar文件、配置文件、计算所得的输入划分）复制到一个以作业ID命名的目录中JobTracker的文件系统。</li>
<li>通过调用JobTracker的submitJob()方法，告诉JobTracker作业准备执行</li>
<li>JobTracker接收到submitJob()方法调用后，把此调用放到一个内部队列中，交由作业调</li>
<li>器进行调度，并对其进行初始化</li>
<li>创建运行任务列表，作业调度去首先从共享文件系统中获取JobClient已经计算好的输入划分信息（图中step6），然后为每个划分创建一个Map任务（一个split对应一个map，有多少split就有多少map）。</li>
<li>TaskTracker执行一个简单的循环，定期发送心跳（heartbeat）调用JobTracker</li>
</ol>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><ol>
<li><strong>输入分片（input split）</strong>：在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组，输入分片（input split）往往和hdfs的block（块）关系很密切，假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split），换句话说我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点；</li>
<li><strong>map阶段</strong>：就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行；</li>
<li><strong>combiner阶段</strong>：combiner阶段是程序员可以选择的，combiner其实也是一种reduce操作，因此我们看见WordCount类里是用reduce进行加载的。Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作，例如我们对文件里的单词频率做统计，map计算时候如果碰到一个hadoop的单词就会记录为1，但是这篇文章里hadoop可能会出现n多次，那么map输出文件冗余就会很多，因此在reduce计算前对相同的key做一个合并操作，那么文件会变小，这样就提高了宽带的传输效率，毕竟hadoop计算力宽带资源往往是计算的瓶颈也是最为宝贵的资源，但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入，例如：如果计算只是求总数，最大值，最小值可以使用combiner，但是做平均值计算使用combiner的话，最终的reduce计算结果就会出错；</li>
<li><strong>shuffle阶段</strong>：将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。这里我不讲怎么优化shuffle阶段，讲讲shuffle阶段的原理，因为大部分的书籍里都没讲清楚shuffle阶段。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件。这个过程里还会有一个Partitioner操作，对于这个操作很多人都很迷糊，其实Partitioner操作和map阶段的输入分片（Input split）很像，一个Partitioner对应一个reduce作业，如果我们mapreduce操作只有一个reduce操作，那么Partitioner就只有一个，如果我们有多个reduce操作，那么Partitioner对应的就会有多个，Partitioner因此就是reduce的输入分片，这个程序员可以编程控制，主要是根据实际key和value的值，根据实际业务类型或者为了更好的reduce负载均衡要求进行，这是提高reduce效率的一个关键所在。到了reduce阶段就是合并map输出文件了，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个，程序员也可以在配置文件更改复制线程的个数，这个复制过程和map写入磁盘过程类似，也有阀值和内存大小，阀值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了；</li>
<li><strong>reduce阶段</strong>：和map函数一样也是程序员编写的，最终结果是存储在hdfs上的。</li>
</ol>
<h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><p>YARN（Yet Another Resource Negotiator）,下一代MapReduce框架的名称，为了容易记忆，一般称为MRv2（MapReduce version 2）。该框架已经不再是一个传统的MapReduce框架，甚至与MapReduce无关，她是一个通用的运行时框架，用户可以编写自己的计算框架，在该运行环境中运行。用于自己编写的框架作为客户端的一个lib，在运用提交作业时打包即可。</p>
<h3 id="why-YARN-instead-of-MR"><a href="#why-YARN-instead-of-MR" class="headerlink" title="why YARN instead of MR"></a>why YARN instead of MR</h3><h4 id="MR-的缺点"><a href="#MR-的缺点" class="headerlink" title="MR 的缺点"></a>MR 的缺点</h4><p>经典 MapReduce 的最严重的限制主要关系到<strong>可伸缩性、资源利用和对与 MapReduce 不同的工作负载的支持</strong>。在 MapReduce 框架中，作业执行受两种类型的进程控制：</p>
<ul>
<li>一个称为 JobTracker 的主要进程，它协调在集群上运行的所有作业，分配要在 TaskTracker 上运行的 map 和 reduce 任务。</li>
<li>许多称为 TaskTracker 的下级进程，它们运行分配的任务并定期向 JobTracker 报告进度。<br>大型的 Hadoop 集群显现出了由单个 JobTracker 导致的可伸缩性瓶颈。</li>
</ul>
<p>此外，较小和较大的 Hadoop 集群都从未最高效地使用他们的计算资源。在 Hadoop MapReduce 中，每个从属节点上的计算资源由集群管理员分解为固定数量的 map 和 reduce slot，这些 slot 不可替代。设定 map slot 和 reduce slot 的数量后，节点在任何时刻都不能运行比 map slot 更多的 map 任务，即使没有 reduce 任务在运行。这影响了集群的利用率，因为在所有 map slot 都被使用（而且我们还需要更多）时，我们无法使用任何 reduce slot，即使它们可用，反之亦然。<br>Hadoop 设计为仅运行 MapReduce 作业。随着替代性的编程模型（比如 Apache Giraph 所提供的图形处理）的到来，除 MapReduce 外，越来越需要为可通过高效的、公平的方式在同一个集群上运行并共享资源的其他编程模型提供支持。</p>
<h4 id="原MapReduce框架的不足"><a href="#原MapReduce框架的不足" class="headerlink" title="原MapReduce框架的不足"></a>原MapReduce框架的不足</h4><ul>
<li>JobTracker是集群事务的集中处理点，存在单点故障</li>
<li>JobTracker是集群事务的集中处理点，存在单点故障</li>
<li>在taskTracker端，用map/reduce task作为资源的表示过于简单，没有考虑到CPU、内存等资源情况，当把两个需要消耗大内存的task调度到一起，很容易出现OOM</li>
<li>把资源强制划分为map/reduce slot,当只有map task时，reduce slot不能用；当只有reduce task时，map slot不能用，容易造成资源利用不足。</li>
</ul>
<h4 id="解决可伸缩性问题"><a href="#解决可伸缩性问题" class="headerlink" title="解决可伸缩性问题"></a>解决可伸缩性问题</h4><p>在 Hadoop MapReduce 中，JobTracker 具有两种不同的职责：</p>
<ul>
<li>管理集群中的计算资源，这涉及到维护活动节点列表、可用和占用的 map 和 reduce slots 列表，以及依据所选的调度策略将可用 slots 分配给合适的作业和任务</li>
<li>协调在集群上运行的所有任务，这涉及到指导 TaskTracker 启动 map 和 reduce 任务，监视任务的执行，重新启动失败的任务，推测性地运行缓慢的任务，计算作业计数器值的总和，等等</li>
</ul>
<p>为单个进程安排大量职责会导致重大的可伸缩性问题，尤其是在较大的集群上，JobTracker 必须不断跟踪数千个 TaskTracker、数百个作业，以及数万个 map 和 reduce 任务。相反，TaskTracker 通常近运行十来个任务，这些任务由勤勉的 JobTracker 分配给它们。</p>
<p>为了解决可伸缩性问题，一个简单而又绝妙的想法应运而生：我们减少了单个 JobTracker 的职责，将部分职责委派给 TaskTracker，因为集群中有许多 TaskTracker。在新设计中，这个概念通过将 JobTracker 的双重职责（集群资源管理和任务协调）分开为两种不同类型的进程来反映。</p>
<h4 id="YARN-的优点"><a href="#YARN-的优点" class="headerlink" title="YARN 的优点"></a>YARN 的优点</h4><ol>
<li>更快地MapReduce计算</li>
<li>对多框架支持</li>
<li>框架升级更容易</li>
</ol>
<center><img src="http://p1.bpimg.com/567571/1ae5e3582108b3aa.png" alt=""></center><br><center>YARN</center>

<ul>
<li>ResourceManager 代替集群管理器</li>
<li>ApplicationMaster 代替一个专用且短暂的 JobTracker</li>
<li>NodeManager 代替 TaskTracker</li>
<li>一个分布式应用程序代替一个 MapReduce 作业</li>
</ul>
<p>一个全局 ResourceManager 以主要后台进程的形式运行，它通常在专用机器上运行，在各种竞争的应用程序之间仲裁可用的集群资源。<br>在用户提交一个应用程序时，一个称为 ApplicationMaster 的轻量型进程实例会启动来协调应用程序内的所有任务的执行。这包括监视任务，重新启动失败的任务，推测性地运行缓慢的任务，以及计算应用程序计数器值的总和。有趣的是，ApplicationMaster 可在容器内运行任何类型的任务。<br>NodeManager 是 TaskTracker 的一种更加普通和高效的版本。没有固定数量的 map 和 reduce slots，NodeManager 拥有许多动态创建的资源容器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Apache Hadoop 是一个开源软件框架，可安装在一个商用机器集群中，使机器可彼此通信并协同工作，以高度分布式的方式共同存储和处理大量数据。最初，Hadoop 包含以下两个主要组件：&lt;strong&gt;Hadoop Distributed Fil
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://yoursite.com/2017/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/09/设计模式之工厂模式/</id>
    <published>2017-03-09T06:30:54.000Z</published>
    <updated>2017-04-06T07:26:32.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>工厂模式</strong>是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。通常我们所说的<strong>工厂模式是指工厂方法模式</strong>，它也是使用频率最高的工厂模式。工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p>
</blockquote>
<h2 id="工厂模式的作用"><a href="#工厂模式的作用" class="headerlink" title="工厂模式的作用"></a>工厂模式的作用</h2><p><strong><em>工厂模式（包括简单工厂模式、工厂方法模式和抽象工厂模式）到底有什么用，很多时候通过反射机制就可以很灵活地创建对象，为什么还要工厂？</em></strong></p>
<p>与一个对象有关的原则有三类：</p>
<ol>
<li><font color="red">对象本身所具有的职责</font></li>
<li><font color="red">创建对象的职责</font></li>
<li><font color="red">使用对象的职责</font>

</li>
</ol>
<p>对象本身的职责很好理解，就是对象自身所具有的一些数据和行为，可通过一些公开的方法来实现它的职责。在本文中，我们将简单讨论一下对象的创建职责和使用职责。</p>
<p>在Java语言中，我们通常有以下几种创建对象的方式：</p>
<ol>
<li>使用new关键字直接创建对象；</li>
<li>通过反射机制创建对象；</li>
<li>通过clone()方法创建对象；</li>
<li>通过工厂类创建对象。</li>
</ol>
<p>毫无疑问，在客户端代码中直接使用new关键字是最简单的一种创建对象的方式，但是它的灵活性较差，下面通过一个简单的示例来加以说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class LoginAction &#123;</div><div class="line">	private UserDAO udao;</div><div class="line">	</div><div class="line">	public LoginAction() &#123;</div><div class="line">		udao = new JDBCUserDAO(); //创建对象</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void execute() &#123;</div><div class="line">		//其他代码</div><div class="line">		udao.findUserById(); //使用对象</div><div class="line">		//其他代码</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在LoginAction类中定义了一个UserDAO类型的对象udao，在LoginAction的构造函数中创建了JDBCUserDAO类型的udao对象，并在execute()方法中调用了udao对象的findUserById()方法，这段代码看上去并没有什么问题。下面我们来分析一下LoginAction和UserDAO之间的关系，LoginAction类负责创建了一个UserDAO子类的对象并使用UserDAO的方法来完成相应的业务处理，也就是说<font color="red">LoginAction即负责udao的创建又负责udao的使用，创建对象和使用对象的职责耦合在一起</font>，这样的设计会导致一个很严重的问题：如果在LoginAction中希望能够使用UserDAO的另一个子类如HibernateUserDAO类型的对象，必须修改LoginAction类的源代码，<strong>违反了“开闭原则”</strong>。如何解决该问题？</p>
<p>最常用的一种解决方法是将udao对象的创建职责从LoginAction类中移除，在LoginAction类之外创建对象，那么谁来负责创建UserDAO对象呢？答案是：<strong>工厂类</strong>。通过引入工厂类，客户类（如LoginAction）不涉及对象的创建，对象的创建者也不会涉及对象的使用。引入工厂类UserDAOFactory之后的结构如图1所示：</p>
<p><img src="http://img.my.csdn.net/uploads/201205/16/1337135120_7984.jpg" alt="enter image description here"></p>
<p> 工厂类的引入将降低因为产品或工厂类改变所造成的维护工作量。如果UserDAO的某个子类的构造函数发生改变或者要需要添加或移除不同的子类，只要维护UserDAOFactory的代码，而不会影响到LoginAction；如果UserDAO的接口发生改变，例如添加、移除方法或改变方法名，只需要修改LoginAction，不会给UserDAOFactory带来任何影响。<br>在所有的工厂模式中，我们都强调一点：<strong>两个类A和B之间的关系应该仅仅是A创建B或是A使用B，而不能两种关系都有</strong>。将<font color="red">对象的创建和使用分离</font>，也使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。</p>
<p>此外，将对象的创建和使用分离还有一个好处<strong>：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中</strong>，这在Joshua Kerievsky的《重构与模式》一书中有专门的一节来进行介绍。因为有时候我们创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项。</p>
<p> 使用工厂类还有一个“不是特别明显的”优点，一个类可能拥有多个构造函数，而在Java、C#等语言中构造函数名字都与类名相同，客户端只能通过传入不同的参数来调用不同的构造函数创建对象，从构造函数和参数列表中也许大家根本不了解不同构造函数所构造的产品的差异。但如果将对象的创建过程封装在工厂类中，<strong>我们可以提供一系列名字完全不同的工厂方法，每一个工厂方法对应一个构造函数，客户端可以以一种更加可读、易懂的方式来创建对象</strong>，而且，从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多。</p>
<p>那么，有人可能会问，<strong>是否需要为设计中的每一个类都配备一个工厂类？答案是：具体情况具体分析。</strong>如果产品类很简单，而且不存在太多变数，其构造过程也很简单，此时无须为其提供工厂类，直接在使用之前实例化即可，例如Java语言中的String类，我们就无须为它专门提供一个StringFactory，这样做反而有点像杀鸡用牛刀，大材小用，而且会导致工厂泛滥，增加系统的复杂度。</p>
<p>工厂模式是为了<font color="red"><strong>将对象的创建和使用分离，也使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护，防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中</strong></font>。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/7523392" target="_blank" rel="external">转载：创建对象与使用对象——谈谈工厂的作用</a></p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</strong></p>
<p>简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong>简单工厂模式结构比较简单，其核心是工厂类的设计, 其结构如下图所示。</p>
<p><img src="http://img.blog.csdn.net/20130711143612921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="简单工厂模式结构"></p>
<p>在简单工厂模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>Factory（工厂角色）</strong>：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</li>
<li><strong>Product（抽象产品角色）</strong>：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
<li><strong>ConcreteProduct（具体产品角色）</strong>：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li>
</ul>
<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。<br>在使用简单工厂模式时，首先需要对产品类进行重构，<strong>不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构</strong>，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">abstract class Product &#123;</div><div class="line">    //所有产品类的公共业务方法</div><div class="line">    public void methodSame() &#123;</div><div class="line">        //公共方法的实现</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //声明抽象业务方法</div><div class="line">    public abstract void methodDiff();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class ConcreteProduct extends Product &#123;</div><div class="line">    //实现业务方法</div><div class="line">    public void methodDiff() &#123;</div><div class="line">        //业务方法的实现</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">class Factory &#123;</div><div class="line">    //静态工厂方法</div><div class="line">	public static Product getProduct(String arg) &#123;</div><div class="line">		Product product = null;</div><div class="line">		if (arg.equalsIgnoreCase(&quot;A&quot;)) &#123;</div><div class="line">			product = new ConcreteProductA();</div><div class="line">            //初始化设置product</div><div class="line">		&#125;</div><div class="line">		else if (arg.equalsIgnoreCase(&quot;B&quot;)) &#123;</div><div class="line">			product = new ConcreteProductB();</div><div class="line">            //初始化设置product</div><div class="line">		&#125;</div><div class="line">		return product;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Client &#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Product product; </div><div class="line">		product = Factory.getProduct(&quot;A&quot;); //通过工厂类创建产品对象</div><div class="line">		product.methodSame();</div><div class="line">		product.methodDiff();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="简单工厂模式总结："><a href="#简单工厂模式总结：" class="headerlink" title="简单工厂模式总结："></a>简单工厂模式总结：</h3><p>简单工厂模式提供了<strong>专门的工厂类用于创建对象，将对象的创建和对象的使用分离开</strong>，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
</ul>
</li>
</ul>
<p><a href="http://blog.csdn.net/lovelion/article/details/9300549" target="_blank" rel="external">转载：工厂三兄弟之简单工厂模式（二）</a></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>简单工厂模式虽然简单，但存在一个很严重的问题。<strong>当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，</strong>如何实现增加新产品而不影响已有代码？工厂方法模式应运而生.</p>
<p>在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p>
<p><strong>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</strong></p>
<p>工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图所示：</p>
<p><img src="http://img.blog.csdn.net/20130712101002890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="工厂方法模式结构"></p>
<p>  在工厂方法模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>Product（抽象产品）</strong>：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li>
<li><strong>ConcreteProduct（具体产品）</strong>：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li>
<li><strong>Factory（抽象工厂）</strong>：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>
<li><strong>ConcreteFactory（具体工厂）</strong>：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li>
</ul>
<p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">interface Factory &#123;</div><div class="line">    public Product factoryMethod();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。<br>在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Factory factory;</div><div class="line">factory = new ConcreteFactory(); //可以结合配置文件和反射机制来实现</div><div class="line">Product product;</div><div class="line">product = factory.factoryMethod();</div></pre></td></tr></table></figure>
<p>可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</p>
<h3 id="工厂方法模式总结"><a href="#工厂方法模式总结" class="headerlink" title="工厂方法模式总结"></a>工厂方法模式总结</h3><ul>
<li><strong>优点</strong><ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li><strong>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键</strong>。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li>
<li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
</ul>
</li>
</ul>
<p><a href="http://blog.csdn.net/lovelion/article/details/9307137" target="_blank" rel="external">参考：工厂三兄弟之工厂方法模式（三）</a></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</strong></p>
<p>在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图所示：</p>
<p><img src="http://img.blog.csdn.net/20130713163800203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抽象工厂模式结构"></p>
<p>在抽象工厂模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>AbstractFactory（抽象工厂</strong>）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li><strong>ConcreteFactory（具体工厂）</strong>：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li><strong>AbstractProduct（抽象产品</strong>）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li><p><strong>ConcreteProduct（具体产品）</strong>：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</p>
<p>在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> class ConcreteFactory1 extends AbstractFactory &#123;</div><div class="line">	    //工厂方法一</div><div class="line">		public AbstractProductA createProductA() &#123;</div><div class="line">		    return new ConcreteProductA1();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//工厂方法二</div><div class="line">		public AbstractProductB createProductB() &#123;</div><div class="line">		    return new ConcreteProductB1();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p> 与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建。</p>
<p><strong>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。</strong></p>
<h3 id="“开闭原则”的倾斜性"><a href="#“开闭原则”的倾斜性" class="headerlink" title="“开闭原则”的倾斜性"></a>“开闭原则”的倾斜性</h3><p><strong>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为<font color="red">“开闭原则”的倾斜性。</font></strong>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<ul>
<li>增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</li>
<li>加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</li>
</ul>
<p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p>
<h3 id="抽象工厂模式总结"><a href="#抽象工厂模式总结" class="headerlink" title="抽象工厂模式总结"></a>抽象工厂模式总结</h3><ul>
<li><strong>优点</strong><ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。通常我们所说的&lt;strong&gt;工厂模式是指工厂方法模式&lt;/strong&gt;，它也是使用频率最高的工厂模式。工厂模式在Java程序系统可以说
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML类图关系总结</title>
    <link href="http://yoursite.com/2017/03/09/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/03/09/UML类图关系总结/</id>
    <published>2017-03-09T01:30:09.000Z</published>
    <updated>2017-03-09T02:42:48.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)</p>
</blockquote>
<h1 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a><strong>泛化（Generalization）</strong></h1><ul>
<li><strong>泛化关系</strong>：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。</li>
<li><strong>箭头指向</strong>：带三角箭头的实线，箭头指向父类。</li>
</ul>
<center><img src="http://i1.piimg.com/567571/8bb8a8d6ae956e7e.jpg" alt=""></center>

<h1 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a><strong>实现（Realization）</strong></h1><ul>
<li><strong>实现关系</strong>：是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li>
<li><strong>箭头指向</strong>：带三角箭头的虚线，箭头指向接口。</li>
</ul>
<center><img src="http://p1.bqimg.com/567571/ad739d8b8fb0bf74.jpg" alt=""></center>

<h1 id="关联（Association"><a href="#关联（Association" class="headerlink" title="关联（Association)"></a><strong>关联（Association)</strong></h1><ul>
<li><strong>关联关系</strong>：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</li>
<li><strong>代码体现</strong> : 成员变量</li>
<li><strong>箭头及指向</strong> : 带普通箭头的实心线，指向被拥有者</li>
</ul>
<center><img src="http://p1.bpimg.com/567571/4181134e316a8b07.jpg" alt=""></center>

<h1 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a><strong>聚合（Aggregation）</strong></h1><ul>
<li><strong>聚合关系</strong>：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<strong>聚合关系是关联关系的一种，是强的关联关系</strong>；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li>
<li><strong>代码体现</strong>： 成员变量</li>
<li><strong>箭头及指向</strong>：带空心菱形的实心线，菱形指向整体</li>
</ul>
<center><img src="http://i1.piimg.com/567571/344243f0dbdc8c11.jpg" alt=""></center>

<h1 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a><strong>组合(Composition)</strong></h1><ul>
<li><strong>组合关系</strong>：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 <strong>组合关系是关联关系的一种，是比聚合关系还要强的关系</strong>，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</li>
<li><strong>代码实现</strong>：成员变量</li>
<li><strong>箭头及指向</strong> ：带实心菱形的实线，菱形指向整体</li>
</ul>
<center><img src="http://i1.piimg.com/567571/ed127ef86b26d6a9.jpg" alt=""></center>

<h1 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a><strong>依赖(Dependency)</strong></h1><ul>
<li><strong>依赖关系</strong>：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。</li>
<li><strong>代码表现</strong>：局部变量、方法的参数或者对静态方法的调用</li>
<li><strong>箭头及指向</strong>：带箭头的虚线，指向被使用者</li>
</ul>
<center><img src="http://i1.piimg.com/567571/b456971cef8542cf.jpg" alt=""></center>

<h1 id="各种关系的强弱顺序："><a href="#各种关系的强弱顺序：" class="headerlink" title="各种关系的强弱顺序："></a>各种关系的强弱顺序：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</div></pre></td></tr></table></figure>
<p><a href="http://www.open-open.com/lib/view/open1328059700311.html" target="_blank" rel="external">转载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)&lt;/p&gt;

    
    </summary>
    
      <category term="UML" scheme="http://yoursite.com/categories/UML/"/>
    
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
      <category term="类图" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 基本概念及原理</title>
    <link href="http://yoursite.com/2017/03/01/Quartz%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/01/Quartz 基本概念及原理/</id>
    <published>2017-03-01T06:59:45.000Z</published>
    <updated>2017-03-01T09:45:19.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Quartz 是 OpenSymphony 开源组织在任务调度领域的一个开源项目，完全基于 Java 实现。作为一个优秀的开源调度框架，Quartz 具有功能强大，应用灵活，易于集成。<a href="http：//www.quartz-scheduler.org/">官网</a></p>
<ol>
<li>强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；</li>
<li>灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；</li>
<li>分布式和集群能力，Terracotta 收购后在原来功能基础上作了进一步提升。</li>
<li>另外，作为 Spring 默认的调度框架，Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。</li>
</ol>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><strong>Scheduler</strong>：任务调度器，是实际执行任务调度的控制器。在spring中通过SchedulerFactoryBean封装起来；</li>
<li><strong>Trigger</strong>：触发器，用于定义任务调度的时间规则，有SimpleTrigger,CronTrigger,DateIntervalTrigger和NthIncludedDayTrigger，其中CronTrigger用的比较多，本文主要介绍这种方式；</li>
<li><strong>Calendar</strong>：它是一些日历特定时间点的集合。一个trigger可以包含多个Calendar，以便排除或包含某些时间点；</li>
<li><strong>JobDetail</strong>：用来描述Job实现类及其它相关的静态信息，如Job名字、关联监听器等信息。在spring中有JobDetailFactoryBean和 MethodInvokingJobDetailFactoryBean两种实现，如果任务调度只需要执行某个类的某个方法，就可以通过MethodInvokingJobDetailFactoryBean来调用；</li>
<li><strong>Job</strong>：是一个接口，只有一个方法void execute(JobExecutionContext context),开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中。实现Job接口的任务，默认是无状态的，若要将Job设置成有状态的，在quartz中是给实现的Job添加@DisallowConcurrentExecution注解（以前是实现StatefulJob接口，现在已被Deprecated）,在与spring结合中可以在spring配置文件的job detail中配置concurrent参数;</li>
<li><strong>misfire</strong>：错过的，指本来应该被执行但实际没有被执行的任务调度</li>
</ol>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h2><p>Quartz 任务调度的核心元素是 scheduler, trigger 和 job，其中 trigger 和 job 是任务调度的元数据， scheduler 是实际执行调度的控制器。<br>在 Quartz 中，trigger 是用于定义调度时间的元素，即按照什么时间规则去执行任务。Quartz 中主要提供了四种类型的 trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，和 NthIncludedDayTrigger。这四种 trigger 可以满足企业应用中的绝大部分需求。<br>在 Quartz 中，job 用于表示被调度的任务。主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。对于同一个 trigger 来说，有状态的 job 不能被并行执行，只有上一次触发的任务被执行完之后，才能触发下一次执行。Job 主要有两种属性：volatility 和 durability，其中 volatility 表示任务是否被持久化到数据库存储，而 durability 表示在没有 trigger 关联的时候任务是否被保留。两者都是在值为 true 的时候任务被持久化或保留。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job。<br>在 Quartz 中， scheduler 由 scheduler 工厂创建：DirectSchedulerFactory 或者 StdSchedulerFactory。 第二种工厂 StdSchedulerFactory 使用较多，因为 DirectSchedulerFactory 使用起来不够方便，需要作许多详细的手工编码设置。 Scheduler 主要有三种：RemoteMBeanScheduler， RemoteScheduler 和 StdScheduler。<br><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/image001.gif" alt=""><br>图 1-Quartz 核心元素关系图<br>在 Quartz 中，有两类线程，Scheduler 调度线程和任务执行线程，其中任务执行线程通常使用一个线程池维护一组线程。<br><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/image002.gif" alt=""><br>图 2-Quartz 线程视图<br>Scheduler 调度线程主要有两个： 执行常规调度的线程，和执行 misfired trigger 的线程。常规调度线程轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。Misfire 线程是扫描所有的 trigger，查看是否有 misfired trigger，如果有的话根据 misfire 的策略分别处理。下图描述了这两个线程的基本流程：<br><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/image003.png" alt=""><br>图 3-Quartz 调度线程流程图</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>Quartz 中的 trigger 和 job 需要存储下来才能被使用。Quartz 中有两种存储方式：RAMJobStore, JobStoreSupport，其中 RAMJobStore 是将 trigger 和 job 存储在内存中，而 JobStoreSupport 是基于 jdbc 将 trigger 和 job 存储到数据库中。RAMJobStore 的存取速度非常快，但是由于其在系统被停止后所有的数据都会丢失，所以在通常应用中，都是使用 JobStoreSupport。<br>在 Quartz 中，JobStoreSupport 使用一个驱动代理来操作 trigger 和 job 的数据存储：StdJDBCDelegate。StdJDBCDelegate 实现了大部分基于标准 JDBC 的功能接口，但是对于各种数据库来说，需要根据其具体实现的特点做某些特殊处理，因此各种数据库需要扩展 StdJDBCDelegate 以实现这些特殊处理。Quartz 已经自带了一些数据库的扩展实现，可以直接使用</p>
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>quartz集群是通过数据库表来感知其他的应用的，各个节点之间并没有直接的通信。只有使用持久的JobStore才能完成Quartz集群。<br>数据库表：以前有12张表，现在只有11张表，现在没有存储listener相关的表，多了QRTZ_SIMPROP_TRIGGERS表：</p>
<table>
<thead>
<tr>
<th><strong>Table name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QRTZ_CALENDARS</td>
<td style="text-align:left">存储Quartz的Calendar信息</td>
</tr>
<tr>
<td>QRTZ_CRON_TRIGGERS</td>
<td style="text-align:left">存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td>QRTZ_FIRED_TRIGGERS</td>
<td style="text-align:left">存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td>QRTZ_PAUSED_TRIGGER_GRPS</td>
<td style="text-align:left">存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td>QRTZ_SCHEDULER_STATE</td>
<td style="text-align:left">存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td><strong>QRTZ_LOCKS</strong></td>
<td style="text-align:left">存储程序的悲观锁的信息</td>
</tr>
<tr>
<td>QRTZ_JOB_DETAILS</td>
<td style="text-align:left">存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td>QRTZ_SIMPLE_TRIGGERS</td>
<td style="text-align:left">存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td>QRTZ_BLOG_TRIGGERS</td>
<td style="text-align:left">Trigger作为Blob类型存储</td>
</tr>
<tr>
<td>QRTZ_TRIGGERS</td>
<td style="text-align:left">存储已配置的Trigger的信息</td>
</tr>
<tr>
<td>QRTZ_SIMPROP_TRIGGERS</td>
</tr>
</tbody>
</table>
<p>QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表,包括以下几个锁：CALENDAR_ACCESS 、JOB_ACCESS、MISFIRE_ACCESS 、STATE_ACCESS 、TRIGGER_ACCESS。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>若quartz是配置在spring中，当服务器启动时，就会装载相关的bean。SchedulerFactoryBean实现了InitializingBean接口，因此在初始化bean的时候，会执行afterPropertiesSet方法，该方法将会调用SchedulerFactory(DirectSchedulerFactory 或者 StdSchedulerFactory，通常用StdSchedulerFactory)创建Scheduler。SchedulerFactory在创建quartzScheduler的过程中，将会读取配置参数，初始化各个组件，关键组件如下：</p>
<ul>
<li><p><strong>ThreadPool</strong> ：一般是使用SimpleThreadPool,SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。在SimpleThreadPool中有三个list：workers-存放池中所有的线程引用，availWorkers-存放所有空闲的线程，busyWorkers-存放所有工作中的线程。线程池的配置参数如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">org.quartz.threadPool.class： org.quartz.simpl.SimpleThreadPool</div><div class="line">org.quartz.threadPool.threadCount： 10</div><div class="line">org.quartz.threadPool.threadPriority： 5</div><div class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread： true</div></pre></td></tr></table></figure>
</li>
<li><p><strong>JobStore</strong>：分为存储在内存的RAMJobStore和存储在数据库的JobStoreSupport(包括JobStoreTX和JobStoreCMT两种实现，JobStoreCMT是依赖于容器来进行事务的管理，而JobStoreTX是自己管理事务），若要使用集群要使用JobStoreSupport的方式；</p>
</li>
<li><strong>QuartzSchedulerThread</strong>：用来进行任务调度的线程，在初始化的时候paused=true,halted=false,虽然线程开始运行了，但是paused=true，线程会一直等待，直到start方法将paused置为false；<br>另外，SchedulerFactoryBean还实现了SmartLifeCycle接口，因此初始化完成后，会执行start()方法，该方法将主要会执行以下的几个动作：</li>
<li>创建<strong>ClusterManager</strong>线程并启动线程：该线程用来进行集群故障检测和处理，将在下文详细讨论；</li>
<li>创建<strong>MisfireHandler</strong>线程并启动线程：该线程用来进行misfire任务的处理，将在下文详细讨论；</li>
<li>置<strong>QuartzSchedulerThread</strong>的paused=false，调度线程才真正开始调度；</li>
</ul>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p><em>待续</em></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https：//www.ibm.com/developerworks/cn/opensource/os-cn-quartz/">基于 Quartz 开发企业级任务调度应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Quartz 是 OpenSymphony 开源组织在任务调度领域的一个开源项目，完全基于 Java 实现。作为一个优秀的开源调度框架，Qu
    
    </summary>
    
      <category term="quartz" scheme="http://yoursite.com/categories/quartz/"/>
    
    
      <category term="quartz，任务调度" scheme="http://yoursite.com/tags/quartz%EF%BC%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 创建线程</title>
    <link href="http://yoursite.com/2017/02/24/JAVA%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/24/JAVA 创建线程/</id>
    <published>2017-02-24T02:54:10.000Z</published>
    <updated>2017-02-24T06:40:14.245Z</updated>
    
    <content type="html"><![CDATA[<p>Java提供了线程类Thread来创建多线程的程序。其实，创建线程与创建普通的类的对象的操作是一样的，而线程就是Thread类或其子类的实例对象。每个Thread对象描述了一个单独的线程。要产生一个线程，有两种方法：</p>
<ul>
<li>需要从Java.lang.Thread类派生一个新的线程类，重写它的run()方法； </li>
<li>实现Runnalbe接口，重载Runnalbe接口中的run()方法。</li>
</ul>
<p><strong>在Java中，类仅支持单继承，也就是说，当定义一个新的类的时候，它只能扩展一个外部类.这样，如果创建自定义线程类的时候是通过扩展 Thread类的方法来实现的，那么这个自定义类就不能再去扩展其他的类，也就无法实现更加复杂的功能。因此，如果自定义类必须扩展其他的类，那么就可以使用实现Runnable接口的方法来定义该类为线程类，这样就可以避免Java单继承所带来的局限性。<br>还有一点最重要的就是使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享.</strong></p>
<h2 id="通过扩展Thread类来创建多线程"><a href="#通过扩展Thread类来创建多线程" class="headerlink" title="通过扩展Thread类来创建多线程"></a>通过扩展Thread类来创建多线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ticket = "</span> + ticket--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> MyThread2().start();</div><div class="line">        <span class="keyword">new</span> MyThread2().start();</div><div class="line">        <span class="keyword">new</span> MyThread2().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">Thread-0 ticket = 5</div><div class="line">Thread-1 ticket = 5</div><div class="line">Thread-2 ticket = 5</div><div class="line">Thread-1 ticket = 4</div><div class="line">Thread-2 ticket = 4</div><div class="line">Thread-0 ticket = 4</div><div class="line">Thread-2 ticket = 3</div><div class="line">Thread-0 ticket = 3</div><div class="line">Thread-1 ticket = 3</div><div class="line">Thread-2 ticket = 2</div><div class="line">Thread-0 ticket = 2</div><div class="line">Thread-1 ticket = 2</div><div class="line">Thread-2 ticket = 1</div><div class="line">Thread-0 ticket = 1</div><div class="line">Thread-1 ticket = 1</div></pre></td></tr></table></figure>
<p>程序中定义一个线程类，它扩展了Thread类。利用扩展的线程类在MyThread2类的主方法中创建了三个线程对象，并通过start()方法分别将它们启动。<br>从结果可以看到，每个线程分别对应5张电影票，之间并无任何关系，这就说明每个线程之间是平等的，没有优先级关系，因此都有机会得到CPU的处理。但是结果<br>显示这三个线程并不是依次交替执行，而是在三个线程同时被执行的情况下，有的线程被分配时间片的机会多，票被提前卖完，而有的线程被分配时间片的机会比较<br>少，票迟一些卖完。<br><strong>可见，利用扩展Thread类创建的多个线程，虽然执行的是相同的代码，但彼此相互独立，且各自拥有自己的资源，互不干扰。</strong></p>
<h2 id="通过实现Runnable接口来创建多线程"><a href="#通过实现Runnable接口来创建多线程" class="headerlink" title="通过实现Runnable接口来创建多线程"></a>通过实现Runnable接口来创建多线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ticket = "</span> + ticket--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread3 my1 = <span class="keyword">new</span> MyThread3();</div><div class="line">        MyThread3 my2 = <span class="keyword">new</span> MyThread3();</div><div class="line">        MyThread3 my3 = <span class="keyword">new</span> MyThread3();</div><div class="line">        <span class="keyword">new</span> Thread(my1).start();</div><div class="line">        <span class="keyword">new</span> Thread(my2).start();</div><div class="line">        <span class="keyword">new</span> Thread(my3).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">Thread-0 ticket = 5</div><div class="line">Thread-1 ticket = 5</div><div class="line">Thread-2 ticket = 5</div><div class="line">Thread-2 ticket = 4</div><div class="line">Thread-1 ticket = 4</div><div class="line">Thread-0 ticket = 4</div><div class="line">Thread-2 ticket = 3</div><div class="line">Thread-0 ticket = 3</div><div class="line">Thread-1 ticket = 3</div><div class="line">Thread-1 ticket = 2</div><div class="line">Thread-0 ticket = 2</div><div class="line">Thread-2 ticket = 2</div><div class="line">Thread-2 ticket = 1</div><div class="line">Thread-1 ticket = 1</div><div class="line">Thread-0 ticket = 1</div></pre></td></tr></table></figure>
<p>由于这三个线程也是彼此独立，各自拥有自己的资源，即100张电影票，因此程序输出的结果和 1 结果大同小异。均是各自线程对自己的5张票进行单独的处理，互不影响。<br>可见，只要现实的情况要求保证新建线程彼此相互独立，各自拥有资源，且互不干扰，采用哪个方式来创建多线程都是可以的。因为这两种方式创建的多线程程序能够实现相同的功能。</p>
<h2 id="通过实现Runnable接口来实现线程间的资源共享"><a href="#通过实现Runnable接口来实现线程间的资源共享" class="headerlink" title="通过实现Runnable接口来实现线程间的资源共享"></a>通过实现Runnable接口来实现线程间的资源共享</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ticket = "</span> + ticket--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread3 my = <span class="keyword">new</span> MyThread3();</div><div class="line">        <span class="keyword">new</span> Thread(my).start();</div><div class="line">        <span class="keyword">new</span> Thread(my).start();</div><div class="line">        <span class="keyword">new</span> Thread(my).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">Thread-2 ticket = 5</div><div class="line">Thread-1 ticket = 4</div><div class="line">Thread-0 ticket = 3</div><div class="line">Thread-2 ticket = 2</div><div class="line">Thread-0 ticket = 1</div><div class="line">Thread-1 ticket = 0</div><div class="line">Thread-2 ticket = -1</div></pre></td></tr></table></figure>
<p>序在内存中仅创建了一个资源，而新建的三个线程都是基于访问这同一资源的，并且由于每个线程上所运行的是相同的代码，因此它们执行的功能也是相同的。可见，如果现实问题中要求必须创建多个线程来执行同一任务，而且这多个线程之间还将共享同一个资源，那么就可以使用实现Runnable接口的方式来创建多线程程序。<br>结果出现-1的原因是多线程并发访问资源ticket时，没有多线程进行线程同步。修改后代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer ticket = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + " sleep ... , i = " + i + ", ticket = " + ticket);</span></div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">synchronized</span> (ticket) &#123; <span class="comment">// 使用synchronized同步</span></div><div class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ticket = "</span> + ticket--);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread3 my = <span class="keyword">new</span> MyThread3();</div><div class="line">        <span class="keyword">new</span> Thread(my).start();</div><div class="line">        <span class="keyword">new</span> Thread(my).start();</div><div class="line">        <span class="keyword">new</span> Thread(my).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">Thread-1 ticket = 5</div><div class="line">Thread-0 ticket = 4</div><div class="line">Thread-2 ticket = 3</div><div class="line">Thread-0 ticket = 2</div><div class="line">Thread-2 ticket = 1</div></pre></td></tr></table></figure>
<p><strong>实现Runnable接口相对于扩展Thread类来说，具有无可比拟的优势。这种方式不仅有利于程序的健壮性，使代码能够被多个线程共享，而且代码和数据资源相对独立，从而特别适合多个具有相同代码的线程去处理同一资源的情况。这样一来，线程、代码和数据资源三者有效分离，很好地体现了面向对象程序设计的思想。因此，几乎所有的多线程程序都是通过实现Runnable接口的方式来完成的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java提供了线程类Thread来创建多线程的程序。其实，创建线程与创建普通的类的对象的操作是一样的，而线程就是Thread类或其子类的实例对象。每个Thread对象描述了一个单独的线程。要产生一个线程，有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要从Java.lang.Th
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA synchronized 详解</title>
    <link href="http://yoursite.com/2017/02/20/JAVA%20synchronized%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/02/20/JAVA synchronized 详解/</id>
    <published>2017-02-20T02:23:48.000Z</published>
    <updated>2017-02-20T06:38:49.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<ol>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块；</li>
<li>当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块；</li>
<li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞；</li>
<li>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞；</li>
<li>以上规则对其它对象锁同样适用。<h1 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h1></li>
</ol>
<ul>
<li><strong>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</strong><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" - synchronized loop "</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread1 t1 = <span class="keyword">new</span> Thread1();</div><div class="line">        Thread ta = <span class="keyword">new</span> Thread(t1, <span class="string">"A"</span>);</div><div class="line">        Thread tb = <span class="keyword">new</span> Thread(t1, <span class="string">"B"</span>);</div><div class="line">        ta.start();</div><div class="line">        tb.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">A - synchronized loop 0</div><div class="line">A - synchronized loop 1</div><div class="line">A - synchronized loop 2</div><div class="line">A - synchronized loop 3</div><div class="line">A - synchronized loop 4</div><div class="line">B - synchronized loop 0</div><div class="line">B - synchronized loop 1</div><div class="line">B - synchronized loop 2</div><div class="line">B - synchronized loop 3</div><div class="line">B - synchronized loop 4</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4t1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">        <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread2 myt2 = <span class="keyword">new</span> Thread2();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(myt2::m4t1, <span class="string">"t1"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(myt2::m4t2, <span class="string">"t2"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 修改Thread2.m4t2()方法：</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">t1 : 4</div><div class="line">t1 : 3</div><div class="line">t1 : 2</div><div class="line">t1 : 1</div><div class="line">t1 : 0</div><div class="line">t2 : 4</div><div class="line">t2 : 3</div><div class="line">t2 : 2</div><div class="line">t2 : 1</div><div class="line">t2 : 0</div></pre></td></tr></table></figure>
<ul>
<li>第三个例子也可以用synchronized方法来实现。<strong>也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。</strong>结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。（方法m4t2xx的synchronized关键字可以在public后，也可以在public前）<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//修改Thread2.m4t2()方法如下：</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">t1 : 4</div><div class="line">t1 : 3</div><div class="line">t1 : 2</div><div class="line">t1 : 1</div><div class="line">t1 : 0</div><div class="line">t2 : 4</div><div class="line">t2 : 3</div><div class="line">t2 : 2</div><div class="line">t2 : 1</div><div class="line">t2 : 0</div></pre></td></tr></table></figure>
<ul>
<li>以上规则对其它对象锁同样适用<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m4t1</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : Inner.m4t1()="</span> + i);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : Inner.m4t2()="</span> + i);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m4t1</span><span class="params">(Inner inner)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (inner) &#123; <span class="comment">//使用对象锁</span></div><div class="line">            inner.m4t1();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">(Inner inner)</span> </span>&#123;</div><div class="line">        inner.m4t2();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread3 myt3 = <span class="keyword">new</span> Thread3();</div><div class="line">        <span class="keyword">final</span> Inner inner = myt3.new Inner();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; myt3.m4t1(inner), <span class="string">"t1"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; myt3.m4t2(inner), <span class="string">"t2"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果：</div><div class="line">t1 : Inner.m4t1()=4</div><div class="line">t2 : Inner.m4t2()=4</div><div class="line">t2 : Inner.m4t2()=3</div><div class="line">t1 : Inner.m4t1()=3</div><div class="line">t2 : Inner.m4t2()=2</div><div class="line">t1 : Inner.m4t1()=2</div><div class="line">t2 : Inner.m4t2()=1</div><div class="line">t1 : Inner.m4t1()=1</div><div class="line">t2 : Inner.m4t2()=0</div><div class="line">t1 : Inner.m4t1()=0</div></pre></td></tr></table></figure>
<p>尽管线程t1获得了对Inner的对象锁，但由于线程t2访问的是同一个Inner中的非同步部分。所以两个线程互不干扰。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 现在在Inner.m4t2()前面加上synchronized：</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">    <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>) &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : Inner.m4t2()="</span> + i);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">结果:</div><div class="line">t1 : Inner.m4t1()=4</div><div class="line">t1 : Inner.m4t1()=3</div><div class="line">t1 : Inner.m4t1()=2</div><div class="line">t1 : Inner.m4t1()=1</div><div class="line">t1 : Inner.m4t1()=0</div><div class="line">t2 : Inner.m4t2()=4</div><div class="line">t2 : Inner.m4t2()=3</div><div class="line">t2 : Inner.m4t2()=2</div><div class="line">t2 : Inner.m4t2()=1</div><div class="line">t2 : Inner.m4t2()=0</div></pre></td></tr></table></figure>
<p>尽管线程t1与t2访问了同一个Inner对象中两个毫不相关的部分,但因为t1先获得了对Inner的对象锁，所以t2对Inner.m4t2()的访问也被阻塞，因为m4t2()是Inner中的一个同步方法。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。  </p>
<ul>
<li>synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">accessVal</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</div></pre></td></tr></table></figure>
<p>synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）</p>
<ul>
<li>synchronized 块：通过 synchronized关键字来声明synchronized 块。<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(syncObject) &#123;  </div><div class="line"><span class="comment">//允许访问控制的代码  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，<br>synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。<br>我们需要明确几点：</p>
<ol>
<li><strong>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问</strong>；</li>
<li><strong>每个对象只有一个锁（lock）与之相关联</strong>；</li>
<li><strong>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</strong>。</li>
</ol>
<p>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p>
<ul>
<li>把synchronized当作函数修饰符时，示例代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//….</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。<br>上边的示例代码等同于如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)      <span class="comment">// (1)</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//…..</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。<strong>可见同步方法实质是将synchronized作用于object reference</strong>。那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱。</p>
<ul>
<li>同步块，示例代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(SomeObject so)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">synchronized</span> (so)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//….. </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]; <span class="comment">// 特殊的instance变量</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="comment">//…</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//…..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock =  new Object()则需要7行操作码</strong>。</p>
<ul>
<li>将synchronized作用于static 函数，示例代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span>   <span class="comment">// 同步的static 函数</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//….</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBBB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Foo.class)   <span class="comment">// class literal(类名称字面常量)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。<br><strong><em>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</em></strong><br>还有一些技巧可以让我们对共享资源的同步访问更加安全：</p>
<ol>
<li>定义private 的instance变量+它的 get方法，而不要定义public/protected的instance变量。如果将变量定义为public，对象在外界可以绕过同步方法的控制而直接取得它，并改动它。这也是JavaBean的标准实现方式之一。</li>
<li>如果instance变量是一个对象，如数组或ArrayList什么的，那上述方法仍然不安全，因为当外界对象通过get方法拿到这个instance对象的引用后，又将其指向另一个对象，那么这private变量也就变了，岂不是很危险。 这个时候就需要将get方法也加上synchronized同步，并且，只返回这个private对象的clone()――这样，调用端得到的就是对象副本的引用了。</li>
</ol>
<p>　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java final 详解</title>
    <link href="http://yoursite.com/2017/02/20/Java%20final%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/02/20/Java final 详解/</id>
    <published>2017-02-20T02:23:48.000Z</published>
    <updated>2017-03-02T03:26:11.683Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。<br>一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。<br><strong><font color="red">使用final修饰方法参数的目的是防止修改这个参数的值，同时也是一种声明和约定，强调这个参数是不可变的</font></strong></p>
</blockquote>
<h1 id="基本类型-amp-引用类型"><a href="#基本类型-amp-引用类型" class="headerlink" title="基本类型 &amp; 引用类型"></a>基本类型 &amp; 引用类型</h1><ul>
<li>基本类型：它的值就是一个数字，一个字符或一个布尔值；</li>
<li>引用类型：是一个对象类型，值是什么呢？<strong>它的值是指向内存空间的引用</strong>，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a;</div><div class="line">a = <span class="number">250</span>; <span class="comment">//声明变量a的同时，系统给a分配了空间。</span></div></pre></td></tr></table></figure>
<p>引用类型就不是了，只给变量分配了引用空间，数据空间没有分配，因为谁都不知道数据是什么，整数，字符？我们看一个错误的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MyDate today;</div><div class="line">today.day = <span class="number">4</span>;   <span class="comment">// 发生错误，因为today对象的数据空间未分配</span></div></pre></td></tr></table></figure></p>
<p>那我们怎么给它赋值？引用类型变量在声明后必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MyDate today;           <span class="comment">// 将变量分配一个保存引用的空间</span></div><div class="line">today = <span class="keyword">new</span> MyDate();   <span class="comment">// 这句话是2步，首先执行new MyDate（），给today变量开辟数据空间，然后再执行赋值操作</span></div><div class="line"><span class="comment">// 引用变量赋值</span></div><div class="line">MyDate a，b;            <span class="comment">// 在内存开辟两个引用空间</span></div><div class="line">a = <span class="keyword">new</span> MyDate();       <span class="comment">// 开辟MyDate对象的数据空间，并把该空间的首地址赋给a</span></div><div class="line">b = a;                  <span class="comment">// 将a存储空间中的地址写到b的存储空间中</span></div></pre></td></tr></table></figure></p>
<p>内存模型如下图：<br><img src="http://p1.bqimg.com/567571/0c171661e31446bc.png" alt=""></p>
<h1 id="引用传递-amp-值传递"><a href="#引用传递-amp-值传递" class="headerlink" title="引用传递 &amp; 值传递"></a>引用传递 &amp; 值传递</h1><ul>
<li>引用传递：除了在函数传值的时候是”引用传递”，在任何用”＝”向对象变量赋值的时候都是”引用传递”。</li>
<li>值传递：基本类型的传递都属于值传递，和C语言一样，当把Java的基本数据类型（如 int，char，double等）作为入口参数传给函数体的时候，传入的参数在函数体内部变成了局部变量，这个局部变量是输入参数的一个拷贝，所有的函 数体内部的操作都是针对这个拷贝的操作，函数执行结束后，这个局部变量也就完成了它的使命，它影响不到作为输入参数的变量。这种方式的参数传递被称为”值 传递”。</li>
</ul>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a>final 变量</h2><p>对于一个final变量，如果是<strong>基本数据类型的变量，则其数值一旦在初始化之后便不能更改</strong>；如果是<strong>引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象</strong>。<br>当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。<br>在上面提到被final修饰的引用变量一旦初始化赋值之后就不能再指向其他的对象，那么该引用变量指向的对象的内容可变吗？看下面这个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> MyClass myClass = <span class="keyword">new</span> MyClass();</div><div class="line">        System.out.println(++myClass.i);</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码可以顺利编译通过并且有输出结果，输出结果为1。<strong>这说明引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。</strong></p>
<h2 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h2><p>使用final方法的原因有两个。第一个原因是<strong>把方法锁定，以防任何继承类修改它的含义</strong>；第二个原因是<strong>效率</strong>。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。<br>因此，<strong><font color="red">只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的</font></strong>。<br><strong><em>注：类的private方法会隐式地被指定为final方法。</em></strong></p>
<h2 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h2><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。<br><strong>在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。</strong></p>
<h1 id="final-amp-static"><a href="#final-amp-static" class="headerlink" title="final &amp; static"></a>final &amp; static</h1><p>很多时候会容易把static和final关键字混淆，<strong><font color="red">static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。</font></strong><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        MyClass myClass1 = <span class="keyword">new</span> MyClass();</div><div class="line">        MyClass myClass2 = <span class="keyword">new</span> MyClass();</div><div class="line">        System.out.println(myClass1.i);</div><div class="line">        System.out.println(myClass1.j);</div><div class="line">        System.out.println(myClass2.i);</div><div class="line">        System.out.println(myClass2.j);</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> i = Math.random();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> j = Math.random();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行这段代码就会发现，每次打印的两个j值都是一样的，而i的值却是不同的。从这里就可以知道final和static变量的区别了。</p>
<h1 id="final-参数"><a href="#final-参数" class="headerlink" title="final 参数"></a>final 参数</h1><p><strong>在方法参数前面加final关键字就是为了防止数据在方法体中被修改。</strong></p>
<ul>
<li><strong>用final修饰基本数据类型</strong>：这时参数的值在方法体内是不能被修改的，即不能被重新赋值。否则编译就通不过。</li>
<li><strong>用final修饰引用类型</strong>：这时参数变量所引用的对象是不能被改变的。作为引用的拷贝，参数在方法体里面不能再引用新的对象。否则编译通不过。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。&lt;br&gt;一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。&lt;br&gt;&lt;strong&gt;&lt;font
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="final" scheme="http://yoursite.com/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 线程安全</title>
    <link href="http://yoursite.com/2017/02/19/JAVA%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2017/02/19/JAVA 线程安全/</id>
    <published>2017-02-19T02:23:48.000Z</published>
    <updated>2017-02-25T08:51:12.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p>java的多线程并发问题最终都会反映在java的内存模型上，所谓线程安全无非是要控制多个线程对某个资源的有序访问或修改。我们都知道计算机有高速缓存的存在，处理器并不是每次处理数据都是取内存的。JVM定义了自己的内存模型，屏蔽了底层平台内存管理细节，对于java开发人员，要清楚在jvm内存模型的基础上，如果解决多线程的可见性和有序性。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>多个线程之间是不能互相传递数据通信的，它们之间的沟通只能通过共享变量来进行。Java内存模型（JMM）规定了jvm有主内存，主内存是多个线程共享的。当new一个对象的时候，也是被分配在主内存中，每个线程都有自己的工作内存，工作内存存储了主存的某些对象的副本，当然线程的工作内存大小是有限制的。当线程操作某个对象时，执行顺序如下：</p>
<ul>
<li>从主存复制变量到当前工作内存 (read and load)</li>
<li>执行代码，改变共享变量值 (use and assign)</li>
<li>用工作内存数据刷新主存相关内容 (store and write)<br>JVM规范定义了线程对主存的操作指令：read，load，use，assign，store，write。当一个共享变量在多个线程的工作内存中都有副本时，如果一个线程修改了这个共享变量，那么其他线程应该能够看到这个被修改后的值，这就是多线程的可见性问题。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>线程在引用变量时不能直接从主内存中引用,如果线程工作内存中没有该变量,则会从主内存中拷贝一个副本到工作内存中,这个过程为read-load,完成后线程会引用该副本。当同一线程再度引用该字段时,有可能重新从主存中获取变量副本(read-load-use),也有可能直接引用原来的副本 (use),也就是说 read,load,use顺序可以由JVM实现系统决定。<br> 线程不能直接为主存中中字段赋值，它会将值指定给工作内存中的变量副本(assign),完成后这个变量副本会同步到主存储区(store- write)，至于何时同步过去，根据JVM实现系统决定.有该字段,则会从主内存中将该字段赋值到工作内存中,这个过程为read-load,完成后线程会引用该变量副本，当同一线程多次重复对字段赋值时,比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">    a++;</div></pre></td></tr></table></figure></p>
<p>线程有可能只对工作内存中的副本进行赋值,只到最后一次赋值后才同步到主存储区，所以assign,store,weite顺序可以由JVM实现系统决定。假设有一个共享变量x，线程a执行x=x+1。从上面的描述中可以知道x=x+1并不是一个原子操作，它的执行过程如下：</p>
<ol>
<li>`从主存中读取变量x副本到工作内存</li>
<li>给x加1</li>
<li>将x加1后的值写回主 存<br>如果另外一个线程b执行x=x-1，执行过程如下：</li>
<li>从主存中读取变量x副本到工作内存</li>
<li>给x减1</li>
<li>将x减1后的值写回主存<br>那么显然，最终的x的值是不可靠的。假设x现在为10，线程a加1，线程b减1，从表面上看，似乎最终x还是为10，但是多线程情况下会有这种情况发生：</li>
<li>线程a从主存读取x副本到工作内存，工作内存中x值为10</li>
<li>线程b从主存读取x副本到工作内存，工作内存中x值为10</li>
<li>线程a将工作内存中x加1，工作内存中x值为11</li>
<li>线程a将x提交主存中，主存中x为11</li>
<li>线程b将工作内存中x值减1，工作内存中x值为9</li>
<li>线程b将x提交到中主存中，主存中x为9<br>同样，x有可能为11，如果x是一个银行账户，线程a存款，线程b扣款，显然这样是有严重问题的，要解决这个问题，必须保证线程a和线程b是有序执行的，并且每个线程执行的加1或减1是一个原子操作。</li>
</ol>
<h1 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h1><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>java用synchronized关键字做为多线程并发环境的执行有序性的保证手段之一。当一段代码会修改共享变量，这一段代码成为互斥区或临界区，为了保证共享变量的正确性，synchronized标示了临界区。典型的用法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(锁)&#123;   </div><div class="line">     临界区代码   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p> volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说，因为<strong>volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。而最彻底的同步要保证有序性和可见性，例如synchronized</strong>。任何被volatile修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。因此对于Valatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改是有序的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java内存模型&quot;&gt;&lt;a href=&quot;#java内存模型&quot; class=&quot;headerlink&quot; title=&quot;java内存模型&quot;&gt;&lt;/a&gt;java内存模型&lt;/h1&gt;&lt;p&gt;java的多线程并发问题最终都会反映在java的内存模型上，所谓线程安全无非是要控制多个线程
    
    </summary>
    
      <category term="java并发" scheme="http://yoursite.com/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java集合类</title>
    <link href="http://yoursite.com/2017/02/17/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/02/17/Java集合类/</id>
    <published>2017-02-17T07:50:22.000Z</published>
    <updated>2017-02-17T08:30:10.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。<br>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：</p>
<ul>
<li><strong>Collection</strong>：  一组”对立”的元素，通常这些元素都服从某种规则<ul>
<li><strong>List</strong> 必须保持元素特定的顺序</li>
<li><strong>Set</strong> 不能有重复元素</li>
<li><strong>Queue</strong> 保持一个队列(先进先出)的顺序</li>
</ul>
</li>
<li><strong>Map</strong>： 一组成对的”键值对”对象</li>
</ul>
<p>Collection和Map的区别在于容器中每个位置保存的元素个数:</p>
<ul>
<li>Collection 每个位置只能保存一个元素(对象)</li>
<li>Map保存的是”键值对”，就像一个小型数据库。我们可以通过”键”找到该键对应的”值”</li>
</ul>
<h1 id="架构层次关系"><a href="#架构层次关系" class="headerlink" title="架构层次关系"></a>架构层次关系</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.util.Collection [I]</div><div class="line">+--java.util.List [I]</div><div class="line">   +--java.util.ArrayList [C]</div><div class="line">   +--java.util.LinkedList [C]</div><div class="line">   +--java.util.Vector [C]</div><div class="line">      +--java.util.Stack [C]</div><div class="line">+--java.util.Set [I]</div><div class="line">   +--java.util.HashSet [C]</div><div class="line">   +--java.util.SortedSet [I]</div><div class="line">      +--java.util.TreeSet [C]</div><div class="line"></div><div class="line">java.util.Map [I]</div><div class="line">+--java.util.SortedMap [I]</div><div class="line">   +--java.util.TreeMap [C]</div><div class="line">+--java.util.Hashtable [C]</div><div class="line">+--java.util.HashMap [C]</div><div class="line">+--java.util.LinkedHashMap [C]</div><div class="line">+--java.util.WeakHashMap [C]</div><div class="line"> </div><div class="line">[I]：接口</div><div class="line">[C]：类</div></pre></td></tr></table></figure>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。<br>所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这 个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。<br>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Iterator it = collection.iterator(); // 获得一个迭代器</div><div class="line">while(it.hasNext()) &#123; </div><div class="line">　　Object obj = it.next(); // 得到下一个元素 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List继承自Collection接口。List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。<br>跟Set集合不同的是，List允许有重复元素。对于满足e1.equals(e2)条件的e1与e2对象元素，可以同时存在于List集合中。当然，也有List的实现类不允许重复元素的存在。<br>除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素， 还能向前或向后遍历。<br>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。<br>注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List list = Collections.synchronizedList(new LinkedList(...));</div></pre></td></tr></table></figure></p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。<br>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。<br>每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并 没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。<br>和LinkedList一样，ArrayList也是非同步的（unsynchronized）。</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set继承自Collection接口。Set是一种不能包含有重复元素的集合，即对于满足e1.equals(e2)条件的e1与e2对象元素，不能同时存在于同一个Set集合里，换句话说，Set集合里任意两个元素e1和e2都满足e1.equals(e2)==false条件，Set最多有一个null元素。 因为Set的这个制约，在使用Set集合的时候，应该注意：</p>
<ul>
<li><strong>为Set集合里的元素的实现类实现一个有效的equals(Object)方法。</strong></li>
<li><strong>对Set的构造函数，传入的Collection参数不能包含重复的元素。</strong></li>
</ul>
<p><em>请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</em></p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证集合的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。<br>HashSet不是同步的，需要用以下语句来进行S同步转换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set s = Collections.synchronizedSet(new HashSet(...));</div></pre></td></tr></table></figure></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map没有继承Collection接口。也就是说Map和Collection是2种不同的集合。Collection可以看作是（value）的集合，而Map可以看作是（key，value）的集合。<br>Map接口由Map的内容提供3种类型的集合视图，一组key集合，一组value集合，或者一组key-value映射关系的集合。</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。<br>添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。<br>Hashtable 通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。<br>由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方 法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相 同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如 果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希 表的操作。<br>如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：<strong>要同时复写equals方法和hashCode方法，而不要只写其中一个。</strong><br>Hashtable是同步的。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<h2 id="对集合操作的工具类"><a href="#对集合操作的工具类" class="headerlink" title="对集合操作的工具类"></a>对集合操作的工具类</h2><ul>
<li>Java提供了java.util.Collections，以及java.util.Arrays类简化对集合的操作。</li>
<li>java.util.Collections主要提供一些static方法用来操作或创建Collection，Map等集合。</li>
<li>java.util.Arrays主要提供static方法对数组进行操作。<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1></li>
<li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li>
<li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。</li>
<li>在除需要排序时使用TreeSet,TreeMap外,都应使用HashSet,HashMap,因为他们 的效率更高。</li>
<li><strong>要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</strong></li>
<li>容器类仅能持有对象引用（指向对象的指针），而不是将对象信息copy一份至数列某位置。一旦将对象置入容器内，便损失了该对象的型别信息。</li>
<li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</li>
</ul>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li>Collection没有get()方法来取得某个元素。只能通过iterator()遍历元素。</li>
<li>Set和Collection拥有一模一样的接口。</li>
<li>List，可以通过get()方法来一次取出一个元素。使用数字来选择一堆对象中的一个，get(0)…。(add/get)</li>
<li>一般使用ArrayList。用LinkedList构造堆栈stack、队列queue。</li>
<li>Map用 put(k,v) / get(k)，还可以使用containsKey()/containsValue()来检查其中是否含有某个key/value。HashMap会利用对象的hashCode来快速找到key。</li>
<li>Map中元素，可以将key序列、value序列单独抽取出来。<ul>
<li>使用keySet()抽取key序列，将map中的所有keys生成一个Set。</li>
<li>使用values()抽取value序列，将map中的所有values生成一个Collection.</li>
<li>为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="collection" scheme="http://yoursite.com/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>impala的原理架构</title>
    <link href="http://yoursite.com/2017/02/16/impala%E7%9A%84%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2017/02/16/impala的原理架构/</id>
    <published>2017-02-16T12:05:26.000Z</published>
    <updated>2017-02-17T02:10:12.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>由cloudera公司主导开发的大数据实时查询分析工具，宣称比原来基于MapReduce的HiveSQL查询速度提升3~90倍，且更加灵活易用。提供类SQL的查询语句，能够查询存储在Hadoop的HDFS和Hbase中的PB级大数据。查询速度快是其最大的卖点。简言之impala作为大数据实时查询分析工具，具有查询速度快，灵活性高，易整合，可伸缩性强等特点。</p>
<ol>
<li>查询速度快。Impala不同于Hive，hive底层执行使用的是MapReduce引擎，仍然是一个批处理过程。不同于hive，impala中间结果不写入磁盘，即使及时通过网络以流的形式传递，大大降低的节点的IO开销。</li>
<li>灵活性高。可以直接查询存储在HDFS上的原生数据，也可以查询经过优化设计而存储的数据，只需要数据的格式能够兼容MapReduce、hive、Pig等等。</li>
<li>易整合。很容易和hadoop系统整合，并使用hadoop生态系统的资源和优势，不需要将数据迁移到特定的存储系统就能满足查询分析的要求。</li>
<li>可伸缩性。可以很好的与一些BI应用系统协同工作，如Microstrategy、Tableau、Qlikview等。</li>
</ol>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><center><img src="http://p1.bpimg.com/567571/e5d78868e694ffd2.jpg" alt=""></center><br>Impala没有再使用缓慢的Hive+MapReduce批处理，而是通过使用与商用并行关系数据库中类似的分布式查询引擎（由Query Planner、Query Coordinator和Query Exec Engine三部分组成），可以直接从HDFS或HBase中用SELECT、JOIN和统计函数查询数据，从而大大降低了延迟。<br>Impala主要由Impalad， State Store和CLI组成。<br>- <strong>Impalad</strong>: 与DataNode运行在同一节点上，由Impalad进程表示，它接收客户端的查询请求（接收查询请求的Impalad为Coordinator，Coordinator通过JNI调用java前端解释SQL查询语句，生成查询计划树，再通过调度器把执行计划分发给具有相应数据的其它Impalad进行执行），读写数据，并行执行查询，并把结果通过网络流式的传送回给Coordinator，由Coordinator返回给客户端。同时Impalad也与State Store保持连接，用于确定哪个Impalad是健康和可以接受新的工作。在Impalad中启动三个ThriftServer: beeswax_server（连接客户端），hs2_server（借用Hive元数据）， be_server（Impalad内部使用）和一个ImpalaServer服务。<br>- <strong>Impala State Store</strong>: 跟踪集群中的Impalad的健康状态及位置信息，由statestored进程表示，它通过创建多个线程来处理Impalad的注册订阅和与各Impalad保持心跳连接，各Impalad都会缓存一份State Store中的信息，当State Store离线后（Impalad发现State Store处于离线时，会进入recovery模式，反复注册，当State Store重新加入集群后，自动恢复正常，更新缓存数据）因为Impalad有State Store的缓存仍然可以工作，但会因为有些Impalad失效了，而已缓存数据无法更新，导致把执行计划分配给了失效的Impalad，导致查询失败。<br>- <strong>CLI</strong>: 提供给用户查询使用的命令行工具（Impala Shell使用python实现），同时Impala还提供了Hue，JDBC， ODBC使用接口。<br>上图可以看出，位于Datanode上的每个impalad进程，都具有Query Planner,QueryCoordinator,Query ExecEnginer这几个组件，每个impala节点在功能上是对等的，也就是说，任何一个节点都能接受外部查询请求。当有一个节点发生故障后，其他节点仍然能够接管，这还得益于HDFS的数据冗余备份机制，即使某个impalad节点挂掉，只要挂掉的节点上的数据在其他节点上有备份，仍然是可以计算的。<br><br># 查询处理过程<br><br><center><img src="http://i1.piimg.com/567571/3149d21b5be7b352.png" alt=""></center>

<h1 id="Impala-VS-Hive"><a href="#Impala-VS-Hive" class="headerlink" title="Impala VS Hive"></a>Impala VS Hive</h1><p> Impala与Hive都是构建在Hadoop之上的数据查询工具各有不同的侧重适应面，但从客户端使用来看Impala与Hive有很多的共同之处，如数据表元数据、ODBC/JDBC驱动、SQL语法、灵活的文件格式、存储资源池等。Impala与Hive在Hadoop中的关系如图 2所示。<strong>Hive适合于长时间的批处理查询分析，而Impala适合于实时交互式SQL查询</strong>。可以先使用hive进行数据转换处理，之后使用Impala在Hive处理后的结果数据集上进行快速的数据分析。</p>
<p><center><img src="http://p1.bpimg.com/567571/f027ca73464a765a.jpg" alt=""></center></p>
<h2 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h2><ul>
<li><strong>数据存储</strong>：使用相同的存储数据池都支持把数据存储于HDFS, HBase。</li>
<li><strong>元数据</strong>：两者使用相同的元数据。</li>
<li><strong>SQL解释处理</strong>：比较相似都是通过词法分析生成执行计划。</li>
<li><strong>执行计划</strong>：<ul>
<li>Hive:依赖于MapReduce执行框架，执行计划分成 map-&gt;shuffle-&gt;reduce-&gt;map-&gt;shuffle-&gt;reduce…的模型。如果一个Query会 被编译成多轮MapReduce，则会有更多的写中间结果。由于MapReduce执行框架本身的特点，过多的中间过程会增加整个Query的执行时间。</li>
<li>Impala:把执行计划表现为一棵完整的执行计划树，可以更自然地分发执行计划到各个Impalad执行查询，而不用像Hive那样把它组合成管道型的map-&gt;reduce模式，以此保证Impala有更好的并发性和避免不必要的中间sort与shuffle。</li>
</ul>
</li>
<li><strong>数据流</strong>：<ul>
<li>Hive:采用推的方式，每一个计算节点计算完成后将数据主动推给后续节点。</li>
<li>Impala:采用拉的方式，后续节点通过getNext主动向前面节点要数据，以此方式数据可以流式的返回给客户端，且只要有1条数据被处理完，就可以立即展现出来，而不用等到全部处理完成，更符合SQL交互式查询使用。</li>
</ul>
</li>
<li><strong>内存使用</strong>：<ul>
<li>Hive:在执行过程中如果内存放不下所有数据，则会使用外存，以保证Query能顺 序执行完。每一轮MapReduce结束，中间结果也会写入HDFS中，同样由于MapReduce执行架构的特性，shuffle过程也会有写本地磁盘的操作。</li>
<li>Impala:在遇到内存放不下数据时，当前版本1.0.1是直接返回错误，而不会利用外存，以后版本应该会进行改进。这使用得Impala目前处理Query会受到一定的限制，最好还是与Hive配合使用。Impala在多个阶段之间利用网络传输数据，在执行过程不会有写磁盘的操作（insert除外）。</li>
</ul>
</li>
<li><strong>调度</strong>：<ul>
<li>Hive:任务调度依赖于Hadoop的调度策略。</li>
<li>Impala:调度由自己完成，目前只有一种调度器simple-schedule，它会尽量满足数据的局部性，扫描数据的进程尽量靠近数据本身所在的物理机器。调度器目前还比较简单，在SimpleScheduler::GetBackend中可以看到，现在还没有考虑负载，网络IO状况等因素进行调度。但目前Impala已经有对执行过程的性能统计分析，应该以后版本会利用这些统计信息进行调度吧。</li>
</ul>
</li>
<li><strong>容错</strong>：<ul>
<li>Hive:依赖于Hadoop的容错能力。</li>
<li>Impala:在查询过程中，没有容错逻辑，如果在执行过程中发生故障，则直接返回错误（这与Impala的设计有关，因为Impala定位于实时查询，一次查询失败，再查一次就好了，再查一次的成本很低）。但从整体来看，Impala是能很好的容错，所有的Impalad是对等的结构，用户可以向任何一个 Impalad提交查询，如果一个Impalad失效，其上正在运行的所有Query都将失败，但用户可以重新提交查询由其它Impalad代替执行，不会影响服务。对于State Store目前只有一个，但当State Store失效，也不会影响服务，每个Impalad都缓存了State Store的信息，只是不能再更新集群状态，有可能会把执行任务分配给已经失效的Impalad执行，导致本次Query失败。</li>
</ul>
</li>
<li><strong>适用面</strong>：<ul>
<li>Hive:复杂的批处理查询任务，数据转换任务。</li>
<li>Impala：实时数据分析，因为不支持UDF，能处理的问题域有一定的限制，与Hive配合使用,对Hive的结果数据集进行实时分析。</li>
</ul>
</li>
</ul>
<h2 id="Impala相对于Hive的优化技术"><a href="#Impala相对于Hive的优化技术" class="headerlink" title="Impala相对于Hive的优化技术"></a>Impala相对于Hive的优化技术</h2><ul>
<li>没有使用 MapReduce进行并行计算，虽然MapReduce是非常好的并行计算框架，但它更多的面向批处理模式，而不是面向交互式的SQL执行。与MapReduce相比：Impala把整个查询分成一执行计划树，而不是一连串的MapReduce任务，在分发执行计划后，Impala使用拉式获取数据的方式获取结果，把结果数据组成按执行树流式传递汇集，减少的了把中间结果写入磁盘的步骤，再从磁盘读取数据的开销。Impala使用服务的方式避免每次执行查询都需要启动的开销，即相比Hive没了MapReduce启动时间。</li>
<li>使用LLVM产生运行代码，针对特定查询生成特定代码，同时使用Inline的方式减少函数调用的开销，加快执行效率。</li>
<li>充分利用可用的硬件指令（SSE4.2）。</li>
<li>更好的IO调度，Impala知道数据块所在的磁盘位置能够更好的利用多磁盘的优势，同时Impala支持直接数据块读取和本地代码计算checksum。</li>
<li>通过选择合适的数据存储格式可以得到最好的性能（Impala支持多种存储格式）。</li>
<li>最大使用内存，中间结果不写磁盘，及时通过网络以stream的方式传递。</li>
</ul>
<h1 id="Impala的优缺点"><a href="#Impala的优缺点" class="headerlink" title="Impala的优缺点"></a>Impala的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>支持SQL查询，快速查询大数据。</li>
<li>可以对已有数据进行查询，减少数据的加载，转换。</li>
<li>多种存储格式可以选择（Parquet, Text, Avro, RCFile, SequeenceFile）。</li>
<li>可以与Hive配合使用。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不支持用户定义函数UDF。</li>
<li>不支持text域的全文搜索。</li>
<li>不支持Transforms。</li>
<li>不支持查询期的容错。</li>
<li>对内存要求高。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;由cloudera公司主导开发的大数据实时查询分析工具，宣称比原来基于MapReduce的HiveSQL查询速度提升3~90倍，且更加灵活易
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="impala" scheme="http://yoursite.com/tags/impala/"/>
    
  </entry>
  
  <entry>
    <title>Hbase原理、基本概念、基本架构</title>
    <link href="http://yoursite.com/2017/02/16/Hbase%E5%8E%9F%E7%90%86%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2017/02/16/Hbase原理、基本概念、基本架构/</id>
    <published>2017-02-16T07:02:22.000Z</published>
    <updated>2017-02-17T02:10:12.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HBase是一个构建在HDFS上的分布式列存储系统；<br>HBase是基于Google BigTable模型开发的，典型的key/value系统；<br>HBase是Apache Hadoop生态系统中的重要一员，主要用于海量结构化数据存储；<br>从逻辑上讲，HBase将数据按照表、行和列进行存储。<br>与hadoop一样，Hbase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。</p>
<h2 id="Hbase-表特点"><a href="#Hbase-表特点" class="headerlink" title="Hbase 表特点"></a>Hbase 表特点</h2><ul>
<li><strong>大</strong>：一个表可以有数十亿行，上百万列；</li>
<li><strong>无模式</strong>：每行都有一个可排序的主键和任意多的列，列可以根据需要动态的增加，同一张表中不同的行可以有截然不同的列；</li>
<li><strong>面向列</strong>：面向列（族）的存储和权限控制，列（族）独立检索；</li>
<li><strong>稀疏</strong>：空（null）列并不占用存储空间，表可以设计的非常稀疏；</li>
<li><strong>数据多版本</strong>：每个单元中的数据可以有多个版本，默认情况下版本号自动分配，是单元格插入时的时间戳；</li>
<li><strong>数据类型单一</strong>：Hbase中的数据都是字符串，没有类型。</li>
</ul>
<h1 id="Hbase-数据模型"><a href="#Hbase-数据模型" class="headerlink" title="Hbase 数据模型"></a>Hbase 数据模型</h1><h2 id="Hbase-逻辑视图"><a href="#Hbase-逻辑视图" class="headerlink" title="Hbase 逻辑视图"></a>Hbase 逻辑视图</h2><center><img src="http://i1.piimg.com/567571/041186b6b6f7c6d5.jpg" alt=""></center><br>## Hbase 基本概念<br>- RowKey：是Byte array，是表中每条记录的“主键”，方便快速查找，Rowkey的设计非常重要。<br>- Column Family：列族，拥有一个名称(string)，包含一个或者多个相关列<br>- Column：属于某一个columnfamily，familyName:columnName，每条记录可动态添加<br>- Version Number：类型为Long，默认值是系统时间戳，可由用户自定义<br>- Value(Cell)：Byte array<br><br># Hbase 物理模型<br>每个column family存储在HDFS上的一个单独文件中，空值不会被保存。<br>Key 和 Version number在每个 column family中均有一份；<br>HBase 为每个值维护了多级索引，即：\<key, column="" family,="" name,="" timestamp\=""><br>## 物理存储<br>-  Table中所有行都按照row key的字典序排列；<br>-  Table在行的方向上分割为多个Region；<br>- Region按大小分割的，每个表开始只有一个Region，随着数据增多，Region不断增大，当增大到一个阀值的时候，Region就会等分会两个新的Region，之后会有越来越多的Region；<br>- Region是Hbase中分布式存储和负载均衡的最小单元，不同Region分布到不同RegionServer上;<br><center><img src="http://p1.bpimg.com/567571/f2b44b62778590fd.png" alt=""></center><br>- Region虽然是分布式存储的最小单元，但并不是存储的最小单元。Region由一个或者多个Store组成，每个store保存一个columns family；每个Strore又由一个memStore和0至多个StoreFile组成，StoreFile包含HFile；memStore存储在内存中，StoreFile存储在HDFS上。<br><center><img src="http://i1.piimg.com/567571/cef3cba296a41b07.png" alt=""></center>

<h1 id="Hbase-架构及基本组件"><a href="#Hbase-架构及基本组件" class="headerlink" title="Hbase 架构及基本组件"></a>Hbase 架构及基本组件</h1><p><center><img src="http://i1.piimg.com/567571/e5524df5446fab63.jpg" alt=""></center></p>
<h2 id="基本组件说明"><a href="#基本组件说明" class="headerlink" title="基本组件说明"></a>基本组件说明</h2><ul>
<li><strong>Client</strong>：包含访问HBase的接口，并维护cache来加快对HBase的访问，比如Region的位置信息</li>
<li><strong>Master</strong><ul>
<li>为Region server分配Region</li>
<li>负责Region server的负载均衡</li>
<li>发现失效的Region server并重新分配其上的Region</li>
<li>管理用户对table的增删改查操作</li>
</ul>
</li>
<li><strong>Region server</strong><ul>
<li>Regionserver维护Region，处理对这些Region的IO请求</li>
<li>Regionserver负责切分在运行过程中变得过大的region</li>
</ul>
</li>
<li><strong>Zookeeper</strong><ul>
<li>通过选举，保证任何时候，集群中只有一个master，Master与RegionServers 启动时会向ZooKeeper注册</li>
<li>存贮所有Region的寻址入口</li>
<li>实时监控Region server的上线和下线信息。并实时通知给Master</li>
<li>存储HBase的schema和table元数据</li>
<li>默认情况下，HBase 管理ZooKeeper 实例，比如， 启动或者停止ZooKeeper</li>
<li>Zookeeper的引入使得Master不再是单点故障</li>
</ul>
</li>
<li><strong>Write-Ahead-Log（WAL）</strong>(预写式日志)<br><center><img src="http://p1.bqimg.com/567571/daa136c290a5faf5.png" alt=""></center><br>该机制用于数据的容错和恢复：<br>每个HRegionServer中都有一个HLog对象，HLog是一个实现Write Ahead Log的类，在每次用户操作写入MemStore的同时，也会写一份数据到HLog文件中，HLog文件定期会滚动出新的，并删除旧的文件（已持久化到StoreFile中的数据）。当HRegionServer意外终止后，HMaster会通过Zookeeper感知到，HMaster首先会处理遗留的 HLog文件，将其中不同Region的Log数据进行拆分，分别放到相应region的目录下，然后再将失效的region重新分配，领取到这些region的HRegionServer在Load Region的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后flush到StoreFiles，完成数据恢复。<h2 id="HBase容错性"><a href="#HBase容错性" class="headerlink" title="HBase容错性"></a>HBase容错性</h2></li>
<li>Master容错：Zookeeper重新选择一个新的Master<ul>
<li>无Master过程中，数据读取仍照常进行；</li>
<li>无master过程中，region切分、负载均衡等无法进行；</li>
</ul>
</li>
<li>RegionServer容错：定时向Zookeeper汇报心跳，如果一旦时间内未出现心跳，Master将该RegionServer上的Region重新分配到其他RegionServer上，失效服务器上“预写”日志由主服务器进行分割并派送给新的RegionServer</li>
<li>Zookeeper容错：Zookeeper是一个可靠地服务，一般配置3或5个Zookeeper实例<h2 id="Region定位流程"><a href="#Region定位流程" class="headerlink" title="Region定位流程"></a>Region定位流程</h2><center><img src="http://i1.piimg.com/567571/bb229506635f0f77.jpg" alt=""></center></li>
<li>寻找RegionServer<br>ZooKeeper–&gt; -ROOT-(单Region)–&gt; .META.–&gt; 用户表</li>
<li>-ROOT-<ul>
<li>表包含.META.表所在的region列表，该表只会有一个Region；</li>
<li>Zookeeper中记录了-ROOT-表的location。</li>
</ul>
</li>
<li>.META.<br>表包含所有的用户空间region列表，以及RegionServer的服务器地址。</li>
</ul>
<h1 id="Hbase-使用场景"><a href="#Hbase-使用场景" class="headerlink" title="Hbase 使用场景"></a>Hbase 使用场景</h1><ul>
<li>大数据量存储，大数据量高并发操作</li>
<li>需要对数据随机读写操作</li>
<li>读写访问均是非常简单的操作</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://wenku.baidu.com/view/b46eadd228ea81c758f578f4.html" target="_blank" rel="external">读和写的流程</a><br><a href="http://blog.csdn.net/dianacody/article/details/39530165" target="_blank" rel="external">HBase的Region机制</a></p>
</key,>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;HBase是一个构建在HDFS上的分布式列存储系统；&lt;br&gt;HBase是基于Google BigTable模型开发的，典型的key/valu
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="Hbase" scheme="http://yoursite.com/tags/Hbase/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>centos7 网桥的配置</title>
    <link href="http://yoursite.com/2017/01/06/centos7%20%E7%BD%91%E6%A1%A5%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/01/06/centos7 网桥的配置/</id>
    <published>2017-01-06T06:11:45.000Z</published>
    <updated>2017-02-17T02:10:12.231Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tonylit.me/2016/04/06/centos7%E7%BD%91%E6%A1%A5%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">http://tonylit.me/2016/04/06/centos7%E7%BD%91%E6%A1%A5%E9%85%8D%E7%BD%AE/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tonylit.me/2016/04/06/centos7%E7%BD%91%E6%A1%A5%E9%85%8D%E7%BD%AE/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tonylit.me/2016
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hive &amp; hbase</title>
    <link href="http://yoursite.com/2016/12/30/hive%20&amp;%20hbase/"/>
    <id>http://yoursite.com/2016/12/30/hive &amp; hbase/</id>
    <published>2016-12-30T01:23:32.000Z</published>
    <updated>2017-02-17T02:10:12.307Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Hive 是为了简化编写MapReduce程序而生的</strong>，使用MapReduce做过数据分析的人都知道，很多分析程序除业务逻辑不同外，程序流程基本一样。在这种 情况下，就需要Hive这样的用戶编程接口。Hive本身不存储和计算数据，它完全依赖于HDFS和MapReduce，Hive中的表纯逻辑，就是些表 的定义等，也就是表的元数据。使用SQL实现Hive是因为SQL大家都熟悉，转换成本低，类似作用的Pig就不是SQL。</p>
<p><strong>HBase为查询而生的</strong>，它通过组织起节点內所有机器的內存，提供一個超大的內存Hash表，它需要组织自己的数据结构，包括磁盘和內存中的，而Hive是不做这个的，表在HBase中是物理表，而不是逻辑表，搜索引擎使用它來存储索引，以满足查询的实时性需求。</p>
<p>hive类似CloudBase，也是基于hadoop分布式计算平台上的提供data warehouse的sql功能的一套软件。使得存储在hadoop里面的海量数据的汇总，即席查询简单化。hive提供了一套QL的查询语言，以sql为基础，使用起来很方便。</p>
<p><strong>HBase是一个分布式的基于列存储的非关系型数据库</strong>。HBase的查询效率很高，主要由于查询和展示结果。</p>
<p><strong>hive 是分布式的关系型数据库</strong>。主要用来并行分布式处理大量数据。hive中的所有查询除了”select <em> from table;”都是需要通过Map\Reduce的方式来执行的。由于要走Map\Reduce，即使一个只有1行1列的表，如果不是通过select </em> from table;方式来查询的，可能也需要8、9秒。但hive比较擅长处理大量数据。当要处理的数据很多，并且Hadoop集群有足够的规模，这时就能体现 出它的优势。<br><em>通过hive的存储接口，hive和Hbase可以整合使用。</em></p>
<ol>
<li>hive是sql语言，通过数据库的方式来操作hdfs文件系统，为了简化编程，底层计算方式为mapreduce。</li>
<li>hive是面向行存储的数据库。</li>
<li>Hive本身不存储和计算数据，它完全依赖于HDFS和MapReduce，Hive中的表纯逻辑。</li>
<li>HBase为查询而生的，它通过组织起节点內所有机器的內存，提供一個超大的內存Hash表</li>
<li>hbase不是关系型数据库，而是一个在hdfs上开发的面向列的分布式数据库，不支持sql。</li>
<li>hbase是物理表，不是逻辑表，提供一个超大的内存hash表，搜索引擎通过它来存储索引，方便查询操作。</li>
<li>hbase是列存储。</li>
</ol>
<p><strong>Hive只供维护用，真正查起来非常非常慢的</strong>！<br>这是因为它的底层是要通过mapreduce分布式计算的，hbase、hive、pig底层都是这样的。但整体来说hadoop还是比较快的，因为它是进行海量数据存储和分布式计算，这个速度已经很不错了。<br>Hive和Hbase有各自不同的特征：<strong>hive是高延迟、结构化和面向分析的，hbase是低延迟、非结构化和面向编程的。Hive数据仓库在hadoop上是高延迟的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Hive 是为了简化编写MapReduce程序而生的&lt;/strong&gt;，使用MapReduce做过数据分析的人都知道，很多分析程序除业务逻辑不同外，程序流程基本一样。在这种 情况下，就需要Hive这样的用戶编程接口。Hive本身不存储和计算数据，它完全依赖于
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hbase" scheme="http://yoursite.com/tags/hbase/"/>
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
      <category term="hdfs" scheme="http://yoursite.com/tags/hdfs/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ下的生产消费者模式与订阅发布模式</title>
    <link href="http://yoursite.com/2016/12/27/RabbitMQ%E4%B8%8B%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/12/27/RabbitMQ下的生产消费者模式与订阅发布模式/</id>
    <published>2016-12-27T02:08:09.000Z</published>
    <updated>2017-02-17T07:50:54.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>生产消费者模式与订阅发布模式是使用消息中间件时常用的两种模式，用于功能解耦和分布式系统间的消息通信。</p>
<h2 id="数据接入"><a href="#数据接入" class="headerlink" title="数据接入"></a>数据接入</h2><p>一个用户行为采集系统，负责从App端采集用户点击行为数据。通常会将数据上报和数据处理分离开，即App端通过REST API上报数据，后端拿到数据后放入队列中就立刻返回，而数据处理则另外使用Worker从队列中取出数据来做，如下图所示：<br><img src="http://p1.bqimg.com/567571/cc3a7aa1c382177e.jpg" alt=""><br>这样做的好处有：第一，功能分离，上报的API接口不关心数据处理功能，只负责接入数据；第二，数据缓冲，数据上报的速率是不可控的，取决于用户使用频率，采用该模式可以一定程度地缓冲数据；第三，易于扩展，在数据量大时，通过增加数据处理Worker来扩展，提高处理速率。这便是典型的<strong>生产消费者模式</strong>，数据上报为生产者，数据处理为消费者。</p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p>一个电商系统，那么，用户“收藏”、“下单”、“付款”等行为都是非常重要的事件，通常后端服务在完成相应的功能处理外，还需要在这些事件点上做很多其他处理动作，比如发送短信通知、记录用户积分等等。我们可以将这些额外的处理动作放到每个模块中，但这并不是优雅的实现，不利于功能解耦和代码维护。<br>??我们需要的是一个事件分发系统，在各个功能模块中将对应的事件发布出来，由对其感兴趣的处理者进行处理。这里涉及两个角色：A对B感兴趣，A是处理者，B是事件，由事件处理器完成二者的绑定，并向消息中心订阅事件。服务模块是后端的业务逻辑服务，在不同的事件点发布事件，事件经过消息中心分发给事件处理器对应的处理者。整个流程如下图所示。这边是典型的<strong>订阅发布模式</strong>。<br><img src="http://p1.bqimg.com/567571/9923cb1907dbecb8.jpg" alt=""></p>
<h1 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>RabbitMQ是基于AMQP协议来实现的消息中间件。AMQP，类似于HTTP协议，也是一个应用层的协议，网络层使用TCP来通信。因此，RabbitMQ也是典型的C-S模型，准确地说是C-S-C模型，因为伴随着RabbitMQ的使用，总是会有Producer与Consumer两个Client和一个Broker Server。<br><img src="http://p1.bqimg.com/567571/4e6b03c753eec38a.jpg" alt=""><br>Client要与Server进行通信，就必须先建立连接，RabbitMQ中有Connection与Channel两个概念，前者就是一个TCP连接，后者是在这个连接上的虚拟概念，负责逻辑上的数据传递，因此，为了节省资源，一般在一个客户端中建立一个Connection，每次使用时再分配一个Channel即可。</p>
<h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><p>Message是RabbitMQ中的消息体概念。类似HTTP传输中，有header和body两部分数据，Message中也有Attributes和Payload两部分数据，前者是一些元信息，后者是传递的消息数据实体。</p>
<h2 id="消息投递"><a href="#消息投递" class="headerlink" title="消息投递"></a>消息投递</h2><p>Exchange、Queue与Routing Key三个概念是理解RabbitMQ消息投递的关键。RabbitMQ中一个核心的原则是，消息不能直接投递到Queue中。Producer只能将自己的消息投递到Exchange中，由Exchange按照routing_key投递到对应的Queue中，具体的架构参见下图。细细品味就会体会到这样设计的精妙之处。<br><img src="http://i1.piimg.com/567571/50d6da93fec7a4e5.jpg" alt=""></p>
<ol>
<li>在Consumer Worker中，声明自己对哪个Exchange感兴趣，并将自己的Queue绑定到自己感兴趣的一组routing_key上，建立相应的映射关系；</li>
<li>在Producer中，将消息投递一个Exchange中，并指明它的routing_key。由此可见，Queue这个概念只是对Consumer可见，Producer并不关心消息被投递到哪个Queue中。 </li>
<li>看过RabbitMQ的”Hello World”教程的童鞋可能会发现在那里面的图中并没有看到Exchange和routing_key的踪迹，但这并不意味着RabbitMQ可以支持直接将消息投递到Queue中，而是在内部使用了默认的Exchange和routing_key了。默认情况下，RabbitMQ使用名称为“amq.direct”的Direct Exchange，routing_key默认名字与Queue保持一致。<br>搞清楚上述概念，就不难理解Exchange的四种类型了。Direct、Fanout、Topic、Headers，区别在于如何将消息从Exchange投递到Queue中。Direct使用具体的routing_key来投递；Fanout则忽略routing_key，直接广播给所有的Queue；Topic是使用模糊匹配来对一组routing_key进行投递；Headers也是忽略routing_key，使用消息中的Headers信息来投递。<h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2></li>
<li>消息确认机制。Consumer处理完消息后，需要发送确认消息给Broker Server，可以选择“确认接收”、“丢弃”、“重新投递”三种方式。如果Consumer在Broker Server收到确认消息之前挂了，Broker Server便会重新投递该消息。</li>
<li>可以选择数据持久化，这样即使RabbitMQ重启，也不会丢失消息。<h1 id="生产消费者模式"><a href="#生产消费者模式" class="headerlink" title="生产消费者模式"></a>生产消费者模式</h1><img src="http://p1.bqimg.com/567571/13204f61927c1570.jpg" alt=""><br>“数据接入”的场景，架构如上图所示，对于上报的数据，如果是special的行为，需要优先处理。从上图可以看到，数据上报端负责将数据投递到RabbitMQ对应的Exchange，并指明routing_key是common还是special。数据处理端，可以根据情况启多个Woker来消费数据，但至少需要两个，一个用来处理common数据，一个用来处理special的数据。<h1 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h1><img src="http://p1.bqimg.com/567571/c820244527b48013.jpg" alt=""><br>“事件分发”的场景，架构如上图所示，使用event name/id来作为RabbitMQ的routing key的名字。Event Processor 01对event 01 和event 02感兴趣，则在启动Consumer Worker时，将自己的Queue绑定到这两个routing key上即可，其他Event Processor也是如此，这样便完成了事件的订阅。当有事件发布时，消息便会按照event name/id被投递到对应的Queue中。 <h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h1><img src="http://www.itdadao.com/articles/c15a901095p0.html" alt=""><br><img src="http://www.cnblogs.com/xiazh/archive/2011/04/29/2004859.html" alt=""><br><img src="http://blog.csdn.net/lk10207160511/article/details/50334173" alt=""></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;生产消费者模式与订阅发布模式是使用消息中间件时常用的两种模式，用于功能解耦和分布式系统间的消息通信。&lt;/p&gt;
&lt;h2 id=&quot;数据接入&quot;&gt;&lt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>离线安装 Cloudera ( CDH 5.x )</title>
    <link href="http://yoursite.com/2016/12/20/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%20Cloudera%20(%20CDH%205.x%20)/"/>
    <id>http://yoursite.com/2016/12/20/离线安装 Cloudera ( CDH 5.x )/</id>
    <published>2016-12-20T02:37:06.000Z</published>
    <updated>2017-02-17T02:10:12.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>系统 centos 6.5</li>
<li>jdk 1.8</li>
<li>三台主机节点<br>  节点角色说明</li>
</ul>
<table>
<thead>
<tr>
<th>ip</th>
<th style="text-align:center">主机名</th>
<th style="text-align:right">角色描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.206.2.181</td>
<td style="text-align:center">hadoop-master</td>
<td style="text-align:right">cm，agent</td>
</tr>
<tr>
<td>10.206.2.182</td>
<td style="text-align:center">hadoop-slave1</td>
<td style="text-align:right">agent</td>
</tr>
<tr>
<td>10.206.2.183</td>
<td style="text-align:center">hadoop-slave2</td>
<td style="text-align:right">agent</td>
</tr>
</tbody>
</table>
<ul>
<li>域名解析<br>配置/etc/hosts, 将以下代码追加到文件末尾即可<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo vim /etc/hosts</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10.206.2.181 hadoop-master </div><div class="line">10.206.2.182 hadoop-slave1</div><div class="line">10.206.2.183 hadoop-slave2</div></pre></td></tr></table></figure>
<ul>
<li>关闭iptable 或配置 iptable策略</li>
<li>关闭SELinux</li>
<li>配置免密码ssh登录</li>
<li>安装jdk（在所有节点操作）</li>
<li>时间同步</li>
<li>准备包（用parcel 方式安装）</li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统 centos 6.5&lt;/li&gt;
&lt;li&gt;jdk 1.8&lt;/li&gt;
&lt;li&gt;三台主机节点&lt;br&gt;  节点角色说明&lt;/li&gt;

    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="cdh" scheme="http://yoursite.com/tags/cdh/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop &amp; Hbase 自动化部署</title>
    <link href="http://yoursite.com/2016/12/08/hadoop&amp;hbase%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2016/12/08/hadoop&amp;hbase自动化部署/</id>
    <published>2016-12-08T07:50:50.000Z</published>
    <updated>2017-02-17T02:10:12.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hadoop-amp-Hbase-自动化部署"><a href="#Hadoop-amp-Hbase-自动化部署" class="headerlink" title="Hadoop &amp; Hbase 自动化部署"></a>Hadoop &amp; Hbase 自动化部署</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目组只有一台高配的服务器，故决定使用docker搭建Hadoop&amp;Hbase等集群环境。</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>hadoop-hbase-hive-cluster-docker-master<ul>
<li>config</li>
<li>Dockerfile</li>
<li>program</li>
<li>resize-cluster.sh</li>
<li>start-container.sh</li>
</ul>
</li>
</ul>
<ol>
<li>config 目录存放配值文件</li>
<li>Dockerfile docker命令脚本，用于构建Dokcer镜像</li>
<li>program hadoop、hbase等安装包目录</li>
<li>resize-cluster.sh 重建镜像脚本</li>
<li>start-container.sh 启动容器脚本</li>
</ol>
<h3 id="Dockerfile-说明"><a href="#Dockerfile-说明" class="headerlink" title="Dockerfile 说明"></a>Dockerfile 说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FROM rastasheep/ubuntu-sshd:latest  # 基于rastasheep/ubuntu-sshd镜像</div><div class="line"></div><div class="line">MAINTAINER zfylin   # author</div><div class="line"></div><div class="line">WORKDIR /root #工作目录</div><div class="line"></div><div class="line"># 配置JDK</div><div class="line">ADD program/jdk-8u101-linux-x64.tar.gz /usr/local</div><div class="line">RUN mv /usr/local/jdk1.8.0_101 /usr/local/jdk</div><div class="line"></div><div class="line"># install hadoop 2.7.2</div><div class="line">ADD program/hadoop-2.7.2.tar.gz /usr/local</div><div class="line">RUN mv /usr/local/hadoop-2.7.2 /usr/local/hadoop</div><div class="line"></div><div class="line"># install hbase 1.2.3 </div><div class="line">ADD program/hbase-1.2.3-bin.tar.gz /usr/local</div><div class="line">RUN mv /usr/local/hbase-1.2.3 /usr/local/hbase</div><div class="line"></div><div class="line"># install hive-2.1.0</div><div class="line">ADD program/apache-hive-2.1.0-bin.tar.gz /usr/local</div><div class="line">RUN mv /usr/local/apache-hive-2.1.0-bin /usr/local/hive</div><div class="line">ADD program/mysql-connector-java-5.1.40.tar.gz /tmp</div><div class="line">RUN cp /tmp/mysql-connector-java-5.1.40/mysql-connector-java-5.1.40-bin.jar /usr/local/hive/lib</div><div class="line"></div><div class="line"># install sqoop-1.4.6</div><div class="line">ADD program/sqoop-1.4.6.bin__hadoop-2.0.4-alpha.tar.gz /usr/local</div><div class="line">RUN mv /usr/local/sqoop-1.4.6.bin__hadoop-2.0.4-alpha /usr/local/sqoop</div><div class="line">RUN cp /tmp/mysql-connector-java-5.1.40/mysql-connector-java-5.1.40-bin.jar /usr/local/sqoop/lib</div><div class="line"></div><div class="line"># set environment variable</div><div class="line">ENV JAVA_HOME=/usr/local/jdk</div><div class="line">ENV HADOOP_HOME=/usr/local/hadoop</div><div class="line">ENV HBASE_HOME=/usr/local/hbase</div><div class="line">ENV HIVE_HOME=/usr/local/hive</div><div class="line">ENV SQOOP_HOME=/usr/local/sqoop</div><div class="line">ENV PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin:/usr/local/hbase/bin:/usr/local/hive/bin:/usr/local/sqoop/bin:/usr/local/jdk/bin</div><div class="line"></div><div class="line"># ssh without key</div><div class="line">RUN ssh-keygen -t rsa -f ~/.ssh/id_rsa -P &apos;&apos; &amp;&amp; \</div><div class="line">    cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div><div class="line"></div><div class="line"># mkdir hadoop log</div><div class="line">RUN  mkdir $HADOOP_HOME/logs</div><div class="line"></div><div class="line"># copy configs</div><div class="line">COPY config/* /tmp/</div><div class="line">RUN mv /tmp/ssh_config ~/.ssh/config &amp;&amp; \</div><div class="line">    mv /tmp/hadoop-env.sh /usr/local/hadoop/etc/hadoop/hadoop-env.sh &amp;&amp; \</div><div class="line">    mv /tmp/hdfs-site.xml $HADOOP_HOME/etc/hadoop/hdfs-site.xml &amp;&amp; \</div><div class="line">    mv /tmp/core-site.xml $HADOOP_HOME/etc/hadoop/core-site.xml &amp;&amp; \</div><div class="line">    mv /tmp/mapred-site.xml $HADOOP_HOME/etc/hadoop/mapred-site.xml &amp;&amp; \</div><div class="line">    mv /tmp/yarn-site.xml $HADOOP_HOME/etc/hadoop/yarn-site.xml &amp;&amp; \</div><div class="line">    mv /tmp/slaves $HADOOP_HOME/etc/hadoop/slaves &amp;&amp; \</div><div class="line">    mv /tmp/start-hadoop.sh ~/start-hadoop.sh &amp;&amp; \</div><div class="line">    mv /tmp/run-wordcount.sh ~/run-wordcount.sh &amp;&amp; \</div><div class="line">    mv /tmp/hbase-env.sh $HBASE_HOME/conf/hbase-env.sh &amp;&amp; \</div><div class="line">    mv /tmp/hbase-site.xml $HBASE_HOME/conf/hbase-site.xml &amp;&amp; \</div><div class="line">    mv /tmp/regionservers $HBASE_HOME/conf/regionservers &amp;&amp; \</div><div class="line">    mv /tmp/start-hbase.sh ~/start-hbase.sh &amp;&amp; \</div><div class="line">    mv /tmp/stop-hbase.sh ~/stop-hbase.sh &amp;&amp; \</div><div class="line">    mv /tmp/hive-site.xml $HIVE_HOME/conf/hive-site.xml &amp;&amp; \</div><div class="line">    mv /tmp/hive-log4j2.properties $HIVE_HOME/conf/hive-log4j2.properties &amp;&amp; \</div><div class="line">    mv /tmp/hive-exec-log4j2.properties $HIVE_HOME/conf/hive-exec-log4j2.properties &amp;&amp; \</div><div class="line">   mv /tmp/hive-config.sh ~/hive-config.sh &amp;&amp; \</div><div class="line">   mv /tmp/sqoop-env.sh $&#123;SQOOP_HOME&#125;/conf</div><div class="line"></div><div class="line">RUN chmod +x ~/start-hadoop.sh &amp;&amp; \</div><div class="line">    chmod +x ~/run-wordcount.sh &amp;&amp; \</div><div class="line">    chmod +x $HADOOP_HOME/sbin/start-dfs.sh &amp;&amp; \</div><div class="line">    chmod +x $HADOOP_HOME/sbin/start-yarn.sh &amp;&amp; \</div><div class="line">    chmod +x ~/start-hbase.sh &amp;&amp; \</div><div class="line">    chmod +x $HBASE_HOME/bin/start-hbase.sh &amp;&amp; \</div><div class="line">    chmod +x ~/stop-hbase.sh &amp;&amp; \</div><div class="line">    chmod +x $&#123;HBASE_HOME&#125;/bin/stop-hbase.sh &amp;&amp; \</div><div class="line">    chmod +x ~/hive-config.sh</div><div class="line"></div><div class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service ssh start; bash&quot;]</div><div class="line"></div><div class="line">EXPOSE 22 7373 7946 9000 50010 50020 50070 50075 50090 50475 8030 8031 8032 8033 8040 8042 8060 8088 50060 2818 60000 60010</div></pre></td></tr></table></figure>
<h3 id="resize-cluster-sh"><a href="#resize-cluster-sh" class="headerlink" title="resize-cluster.sh"></a>resize-cluster.sh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># N is the node number of hadoop cluster</div><div class="line">N=$&#123;1:-3&#125;   # 默认3个节点</div><div class="line"></div><div class="line">if [ $# = 0 ]</div><div class="line">then</div><div class="line">        echo &quot;Please specify the node number of hadoop cluster!&quot;</div><div class="line">        exit 1</div><div class="line">fi</div><div class="line"></div><div class="line"># change slaves file</div><div class="line">i=1</div><div class="line">rm config/slaves</div><div class="line">rm config/regionservers</div><div class="line">while [ $i -lt $N ]</div><div class="line">do</div><div class="line">        echo &quot;hadoop-slave$i&quot; &gt;&gt; config/slaves</div><div class="line">        # 同步修改hbase-site.xml hbase.zookeeper.quorum配置项</div><div class="line">        # 如果 N = 3, 则 value 为 “hadoop-master,hadoop-slave1,hadoop-slave2”</div><div class="line">        # 如果 N = 5, 则 value 为  &quot;hadoop-master,hadoop-slave1,hadoop-slave2,hadoop-slave3, hadoop-slave4&quot;</div><div class="line">        echo &quot;hadoop-slave$i&quot; &gt;&gt; config/regionservers </div><div class="line">        ((i++))</div><div class="line">done</div><div class="line"></div><div class="line">echo &quot;&quot;</div><div class="line"></div><div class="line">echo -e &quot;\nbuild docker hadoop image\n&quot;</div><div class="line"></div><div class="line"># rebuild zfylin/hadoop image</div><div class="line">sudo docker build -t zfylin/hadoop-hbase:1.0 .</div><div class="line"></div><div class="line">echo &quot;&quot;</div></pre></td></tr></table></figure>
<h3 id="start-container-sh"><a href="#start-container-sh" class="headerlink" title="start-container.sh"></a>start-container.sh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># the default node number is 3</div><div class="line">N=$&#123;1:-3&#125;</div><div class="line">HADOOP_IAMGES_NAME=zfylin/hadoop-hbase:1.0</div><div class="line">NET_NAME=none</div><div class="line">VOLUMN_PATH=/home/zfy/data/hadoop-cluster</div><div class="line"></div><div class="line">declare -a users</div><div class="line"># node ip, users[1] 为 master ip，其他为 slave ip</div><div class="line"># 有多少个node，就需要配置多少ip</div><div class="line">users=([1]=&apos;10.206.19.121&apos; [2]=&apos;10.206.19.122&apos; [3]=&apos;10.206.19.123&apos;)</div><div class="line"># host 配置，有多少个node，就需要配置多少host</div><div class="line">h0=&apos;mirror.centos.org:10.204.76.222&apos;</div><div class="line">h1=&apos;hadoop-master:10.206.19.121&apos;</div><div class="line">h2=&apos;hadoop-slave1:10.206.19.122&apos;</div><div class="line">h3=&apos;hadoop-slave2:10.206.19.123&apos;</div><div class="line">prefix=24</div><div class="line">via=&apos;10.206.16.11&apos;</div><div class="line"></div><div class="line"># start hadoop master container</div><div class="line">sudo docker rm -f hadoop-master &amp;&gt; /dev/null</div><div class="line">echo &quot;start hadoop-master container...&quot;</div><div class="line">sudo docker run -itd \</div><div class="line">                --net=$&#123;NET_NAME&#125; \</div><div class="line">                --privileged=true \</div><div class="line">                --name hadoop-master \</div><div class="line">                --hostname hadoop-master \</div><div class="line">                --add-host=&quot;$h0&quot; \</div><div class="line">                --add-host=&quot;$h1&quot; \</div><div class="line">                --add-host=&quot;$h2&quot; \</div><div class="line">                --add-host=&quot;$h3&quot; \</div><div class="line">                -v $&#123;VOLUMN_PATH&#125;/hadoop-master/hdfs:/root/hdfs \</div><div class="line">                $&#123;HADOOP_IAMGES_NAME&#125; &amp;&gt; /dev/null</div><div class="line"></div><div class="line">echo &quot;pipework br33 hadoop-master $&#123;users[1]&#125;/$prefix@$via&quot;</div><div class="line"># pipework 绑定hadoop-master ip</div><div class="line">pipework br33 hadoop-master $&#123;users[1]&#125;/$prefix@$via</div><div class="line"></div><div class="line"># start hadoop slave container</div><div class="line">i=1</div><div class="line">while [ $i -lt $N ]</div><div class="line">do</div><div class="line">        sudo docker rm -f hadoop-slave$i &amp;&gt; /dev/null</div><div class="line">        echo &quot;start hadoop-slave$i container...&quot;</div><div class="line">        sudo docker run -itd \</div><div class="line">                        --net=$&#123;NET_NAME&#125; \</div><div class="line">                        --privileged=true \</div><div class="line">                        --add-host=&quot;$h0&quot; \</div><div class="line">                        --add-host=&quot;$h1&quot; \</div><div class="line">                        --add-host=&quot;$h2&quot; \</div><div class="line">                        --add-host=&quot;$h3&quot; \</div><div class="line">                        --name hadoop-slave$i \</div><div class="line">                        --hostname hadoop-slave$i \</div><div class="line">                        -v $&#123;VOLUMN_PATH&#125;/hadoop-slave$i/hdfs:/root/hdfs \</div><div class="line">                        $&#123;HADOOP_IAMGES_NAME&#125; &amp;&gt; /dev/null</div><div class="line">        host_name=hadoop-slave$i</div><div class="line">        i=$(( $i + 1 ))</div><div class="line">        echo &quot;pipework br33 $host_name $&#123;users[$i]&#125;/$prefix@$via&quot;</div><div class="line">        # pipework 绑定hadoop-slave$i ip</div><div class="line">        pipework br33 $host_name $&#123;users[$i]&#125;/$prefix@$via</div><div class="line"></div><div class="line">done</div><div class="line"></div><div class="line"># get into hadoop master container</div><div class="line">sudo docker exec -it hadoop-master bash</div></pre></td></tr></table></figure>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul>
<li>构建Docker镜像<br>  sudo ./resize-cluster.sh </li>
<li>启动镜像<br> sudo  ./start-container.sh </li>
<li>启动hadoop<br>  ./start-hadoop.sh</li>
<li>启动hbase<br> ./start-hbase.sh</li>
<li>启动hive<br>hiveserver2 start</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hadoop-amp-Hbase-自动化部署&quot;&gt;&lt;a href=&quot;#Hadoop-amp-Hbase-自动化部署&quot; class=&quot;headerlink&quot; title=&quot;Hadoop &amp;amp; Hbase 自动化部署&quot;&gt;&lt;/a&gt;Hadoop &amp;amp; Hbase
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hbase" scheme="http://yoursite.com/tags/hbase/"/>
    
  </entry>
  
</feed>
